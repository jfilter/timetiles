#!/bin/bash

# TimeTiles CLI - Production Management
# Usage: timetiles [command]
#
# This script should be run as the 'timetiles' user (or root, which will
# automatically switch to timetiles). Running as other users will fail.
#
# Install: sudo ln -sf /opt/timetiles/timetiles /usr/local/bin/timetiles

set -eo pipefail

# =============================================================================
# User & Permission Handling
# =============================================================================
# The script needs to run as 'timetiles' user with docker group access.
# If run as root, it re-executes itself as the timetiles user.

DEPLOY_USER="${DEPLOY_USER:-timetiles}"

# If running as root, re-exec as the deploy user with docker group
if [ "$(id -u)" = "0" ]; then
    # Check if deploy user exists
    if id "$DEPLOY_USER" &>/dev/null; then
        exec sg docker -c "sudo -u $DEPLOY_USER $0 $*"
    else
        echo "Warning: User '$DEPLOY_USER' not found, running as root"
    fi
fi

# Verify docker access (non-fatal warning)
if ! docker info &>/dev/null 2>&1; then
    echo "Warning: Cannot connect to Docker. You may need to:"
    echo "  1. Start Docker daemon"
    echo "  2. Add user to docker group: sudo usermod -aG docker $USER"
    echo "  3. Re-login or run: sg docker -c './timetiles $*'"
fi

# Configuration
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
ENV_FILE="$SCRIPT_DIR/.env.production"
COMPOSE_FILE="$SCRIPT_DIR/docker-compose.prod.yml"
TEST_OVERRIDE="$SCRIPT_DIR/docker-compose.test.yml"
SSL_OVERRIDE="$SCRIPT_DIR/docker-compose.ssl-override.yml"

# Build compose command with appropriate overrides
DC_CMD="docker compose -f $COMPOSE_FILE"

# Add SSL override if exists (for self-signed certs when SKIP_SSL=true)
if [ -f "$SSL_OVERRIDE" ]; then
    DC_CMD="$DC_CMD -f $SSL_OVERRIDE"
fi

# Add test override if exists (for CI/testing)
if [ -f "$TEST_OVERRIDE" ]; then
    DC_CMD="$DC_CMD -f $TEST_OVERRIDE"
fi

DC_CMD="$DC_CMD --env-file $ENV_FILE"

# Change to project root for build context
cd "$SCRIPT_DIR/.."

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Alert script location
ALERT_SCRIPT="/opt/timetiles/scripts/alert.sh"

# Send alert if script exists
send_alert() {
    local subject="$1"
    local message="$2"
    if [ -x "$ALERT_SCRIPT" ]; then
        "$ALERT_SCRIPT" "$subject" "$message" 2>/dev/null || true
    fi
}

# Restic configuration
load_restic_config() {
    RESTIC_PASSWORD="${RESTIC_PASSWORD:-}"
    RESTIC_REPOSITORY="${RESTIC_REPOSITORY:-$SCRIPT_DIR/backups/restic-repo}"
    RESTIC_OFFSITE_REPOSITORY="${RESTIC_OFFSITE_REPOSITORY:-}"
    AWS_ACCESS_KEY_ID="${AWS_ACCESS_KEY_ID:-}"
    AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY:-}"
    AWS_ENDPOINT_URL="${AWS_ENDPOINT_URL:-}"
    BACKUP_KEEP_DAILY="${BACKUP_KEEP_DAILY:-7}"
    BACKUP_KEEP_WEEKLY="${BACKUP_KEEP_WEEKLY:-4}"
    BACKUP_KEEP_MONTHLY="${BACKUP_KEEP_MONTHLY:-12}"

    if [[ -z "$RESTIC_PASSWORD" ]]; then
        echo -e "${RED}Error: RESTIC_PASSWORD not set in .env.production${NC}"
        echo "Run bootstrap or manually set RESTIC_PASSWORD"
        exit 1
    fi

    export RESTIC_PASSWORD
    export AWS_ACCESS_KEY_ID
    export AWS_SECRET_ACCESS_KEY
}

# Initialize restic repo if needed
init_restic_repo() {
    local repo="$1"
    local name="$2"

    if [[ "$repo" == s3:* ]]; then
        export AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY
        [[ -n "$AWS_ENDPOINT_URL" ]] && export AWS_ENDPOINT_URL
    fi

    # Check if repo exists
    if ! restic -r "$repo" snapshots &>/dev/null; then
        echo -e "${YELLOW}Initializing $name restic repository...${NC}"
        if ! restic -r "$repo" init 2>&1; then
            # Might already be initialized (race condition or permissions)
            if ! restic -r "$repo" snapshots &>/dev/null; then
                echo -e "${RED}Failed to initialize $name repository${NC}"
                return 1
            fi
        fi
    fi
    return 0
}

# Run restic with proper environment
run_restic() {
    local repo="$1"
    shift

    if [[ "$repo" == s3:* ]]; then
        export AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY
        [[ -n "$AWS_ENDPOINT_URL" ]] && export AWS_ENDPOINT_URL
    fi

    restic -r "$repo" "$@"
}

# Functions
print_usage() {
    echo "Usage: $0 [command]"
    echo ""
    echo "Commands:"
    echo "  setup     - Initial setup (copy env file, generate secrets)"
    echo "  build     - Build Docker images (or pull from registry)"
    echo "  pull      - Pull images from registry"
    echo "  up        - Start all services"
    echo "  down      - Stop all services"
    echo "  restart   - Restart all services"
    echo "  logs      - View logs (follow mode)"
    echo "  backup    - Backup management (full|db|uploads|auto|list|prune|verify|clean)"
    echo "  restore   - Restore from backup"
    echo "  status    - Check service status"
    echo "  ssl       - Initialize Let's Encrypt SSL certificate"
    echo "  update    - Pull latest code and redeploy"
    echo "  check     - Verify all deployment aspects are properly configured"
    echo ""
    echo "Note: Database migrations run automatically on container startup."
    echo ""
}

check_env() {
    if [ ! -f "$ENV_FILE" ]; then
        echo -e "${RED}Error: $ENV_FILE not found!${NC}"
        echo "Run: $0 setup"
        exit 1
    fi
}

init_ssl() {
    echo -e "${YELLOW}Initializing SSL certificate with Let's Encrypt...${NC}"
    
    # Load domain from env file
    source "$ENV_FILE"
    
    if [ -z "$DOMAIN_NAME" ]; then
        echo -e "${RED}Error: DOMAIN_NAME not set in $ENV_FILE${NC}"
        exit 1
    fi
    
    if [ -z "$LETSENCRYPT_EMAIL" ]; then
        echo -e "${RED}Error: LETSENCRYPT_EMAIL not set in $ENV_FILE${NC}"
        exit 1
    fi
    
    echo -e "${YELLOW}Requesting certificate for $DOMAIN_NAME...${NC}"
    
    # Request certificate
    if $DC_CMD run --rm certbot certonly --webroot \
        --webroot-path=/var/www/certbot \
        --email "$LETSENCRYPT_EMAIL" \
        --agree-tos \
        --no-eff-email \
        -d "$DOMAIN_NAME" \
        -d "www.$DOMAIN_NAME"; then
        echo -e "${GREEN}SSL certificate obtained successfully!${NC}"
        # Reload nginx to use new certificate
        $DC_CMD exec nginx nginx -s reload
    else
        echo -e "${RED}Failed to obtain SSL certificate${NC}"
        exit 1
    fi
}

case "$1" in
    setup)
        echo -e "${YELLOW}Setting up production environment...${NC}"
        
        # Copy env file if it doesn't exist
        if [ ! -f "$ENV_FILE" ]; then
            cp "$SCRIPT_DIR/.env.production.example" "$ENV_FILE"
            echo -e "${GREEN}Created $ENV_FILE from template${NC}"
            
            # Generate random secret for Payload
            PAYLOAD_SECRET=$(openssl rand -base64 32 | tr -d '/')
            # Use a delimiter that won't appear in base64 strings
            sed -i.bak "s|PAYLOAD_SECRET=.*|PAYLOAD_SECRET=$PAYLOAD_SECRET|" "$ENV_FILE"
            echo -e "${GREEN}Generated PAYLOAD_SECRET${NC}"
            
            echo -e "${YELLOW}Please edit $ENV_FILE and set:${NC}"
            echo "  - DB_PASSWORD"
            echo "  - DOMAIN_NAME (your domain)"
            echo "  - LETSENCRYPT_EMAIL"
        else
            echo -e "${YELLOW}$ENV_FILE already exists${NC}"
        fi
        ;;
        
    build)
        check_env
        if [ -f "$SCRIPT_DIR/docker-compose.override.yml" ]; then
            echo -e "${YELLOW}Building Docker images locally (override detected)...${NC}"
            $DC_CMD build
            echo -e "${GREEN}Build complete!${NC}"
        else
            echo -e "${YELLOW}Pulling Docker images from registry...${NC}"
            $DC_CMD pull
            echo -e "${GREEN}Pull complete!${NC}"
        fi
        ;;

    pull)
        check_env
        echo -e "${YELLOW}Pulling Docker images from registry...${NC}"
        $DC_CMD pull
        echo -e "${GREEN}Pull complete!${NC}"
        ;;

    up)
        check_env
        echo -e "${YELLOW}Starting services...${NC}"
        $DC_CMD up -d
        echo -e "${GREEN}Services started!${NC}"
        echo "Waiting for services to be ready..."
        sleep 10
        $0 status
        ;;
        
    down)
        check_env
        echo -e "${YELLOW}Stopping services...${NC}"
        $DC_CMD down
        echo -e "${GREEN}Services stopped!${NC}"
        ;;
        
    restart)
        check_env
        echo -e "${YELLOW}Restarting services...${NC}"
        $DC_CMD restart
        echo -e "${GREEN}Services restarted!${NC}"
        ;;
        
    logs)
        check_env
        $DC_CMD logs -f --tail=100
        ;;
        
    backup)
        check_env
        load_restic_config

        OFFSITE=false
        WHAT="full"

        # Parse arguments
        while [[ $# -gt 1 ]]; do
            case "$2" in
                --offsite) OFFSITE=true; shift ;;
                db|database) WHAT="db"; shift ;;
                uploads) WHAT="uploads"; shift ;;
                list|prune|verify|auto) WHAT="$2"; shift; break ;;
                *) shift ;;
            esac
        done

        case "$WHAT" in
            db|database)
                # Initialize local repo
                if ! init_restic_repo "$RESTIC_REPOSITORY" "local"; then
                    exit 1
                fi

                echo -e "${YELLOW}Backing up database...${NC}"

                # Create temp SQL dump
                TEMP_DUMP=$(mktemp)
                trap "rm -f $TEMP_DUMP" EXIT

                if ! $DC_CMD exec -T postgres bash -c 'PGPASSWORD=$POSTGRES_PASS pg_dump -h localhost -U $POSTGRES_USER --clean --if-exists $POSTGRES_DBNAME' > "$TEMP_DUMP"; then
                    echo -e "${RED}Database dump failed${NC}"
                    send_alert "Backup Failed" "Database dump failed at $(date)"
                    exit 1
                fi

                # Backup to local restic repo
                if ! run_restic "$RESTIC_REPOSITORY" backup --tag db --stdin --stdin-filename "database.sql" < "$TEMP_DUMP"; then
                    echo -e "${RED}Restic backup failed${NC}"
                    send_alert "Backup Failed" "Restic backup failed at $(date)"
                    exit 1
                fi

                echo -e "${GREEN}Database backup complete${NC}"

                # Offsite sync
                if $OFFSITE && [[ -n "$RESTIC_OFFSITE_REPOSITORY" ]]; then
                    echo -e "${YELLOW}Syncing to offsite...${NC}"
                    if init_restic_repo "$RESTIC_OFFSITE_REPOSITORY" "offsite" 2>/dev/null; then
                        if run_restic "$RESTIC_OFFSITE_REPOSITORY" backup --tag db --stdin --stdin-filename "database.sql" < "$TEMP_DUMP" 2>/dev/null; then
                            echo -e "${GREEN}Offsite sync complete${NC}"
                        else
                            echo -e "${YELLOW}Offsite sync failed (continuing - local backup succeeded)${NC}"
                        fi
                    else
                        echo -e "${YELLOW}Offsite init failed (write-only credentials?) - skipping${NC}"
                    fi
                fi
                ;;

            uploads)
                if ! init_restic_repo "$RESTIC_REPOSITORY" "local"; then
                    exit 1
                fi

                echo -e "${YELLOW}Backing up uploads...${NC}"

                UPLOAD_VOL=$(docker volume ls -q | grep -E 'timetiles.*uploads' | head -1)
                if [[ -z "$UPLOAD_VOL" ]]; then
                    echo -e "${RED}Upload volume not found${NC}"
                    exit 1
                fi

                # Backup uploads via docker
                if ! docker run --rm \
                    -v "$UPLOAD_VOL:/data:ro" \
                    -e RESTIC_PASSWORD="$RESTIC_PASSWORD" \
                    -v "$RESTIC_REPOSITORY:/repo" \
                    restic/restic -r /repo backup --tag uploads /data; then
                    echo -e "${RED}Uploads backup failed${NC}"
                    send_alert "Backup Failed" "Uploads backup failed at $(date)"
                    exit 1
                fi

                echo -e "${GREEN}Uploads backup complete${NC}"

                # Offsite sync for uploads
                if $OFFSITE && [[ -n "$RESTIC_OFFSITE_REPOSITORY" ]]; then
                    echo -e "${YELLOW}Syncing uploads to offsite...${NC}"
                    # For S3 offsite, run restic directly with volume mount
                    if docker run --rm \
                        -v "$UPLOAD_VOL:/data:ro" \
                        -e RESTIC_PASSWORD="$RESTIC_PASSWORD" \
                        -e AWS_ACCESS_KEY_ID="$AWS_ACCESS_KEY_ID" \
                        -e AWS_SECRET_ACCESS_KEY="$AWS_SECRET_ACCESS_KEY" \
                        ${AWS_ENDPOINT_URL:+-e AWS_ENDPOINT_URL="$AWS_ENDPOINT_URL"} \
                        restic/restic -r "$RESTIC_OFFSITE_REPOSITORY" backup --tag uploads /data 2>/dev/null; then
                        echo -e "${GREEN}Offsite uploads sync complete${NC}"
                    else
                        echo -e "${YELLOW}Offsite uploads sync failed (continuing)${NC}"
                    fi
                fi
                ;;

            full)
                echo -e "${YELLOW}Creating full backup (database + uploads)...${NC}"

                # Run both backups
                BACKUP_ARGS=""
                $OFFSITE && BACKUP_ARGS="--offsite"

                "$0" backup db $BACKUP_ARGS || exit 1
                "$0" backup uploads $BACKUP_ARGS || exit 1

                echo -e "${GREEN}Full backup complete${NC}"
                ;;

            list)
                REPO="$RESTIC_REPOSITORY"
                if [[ "$2" == "--offsite" ]]; then
                    if [[ -z "$RESTIC_OFFSITE_REPOSITORY" ]]; then
                        echo -e "${RED}No offsite repository configured${NC}"
                        exit 1
                    fi
                    REPO="$RESTIC_OFFSITE_REPOSITORY"
                    echo -e "${YELLOW}Listing offsite snapshots...${NC}"
                    echo -e "${YELLOW}(Requires read permissions - may fail with write-only credentials)${NC}"
                fi

                if ! run_restic "$REPO" snapshots 2>/dev/null; then
                    if [[ "$REPO" == "$RESTIC_OFFSITE_REPOSITORY" ]]; then
                        echo -e "${YELLOW}Cannot list offsite snapshots (read permissions required)${NC}"
                        echo "Use AWS console or a machine with read access to view offsite backups"
                    else
                        echo -e "${RED}Failed to list snapshots${NC}"
                        exit 1
                    fi
                fi
                ;;

            prune)
                echo -e "${YELLOW}Applying retention policy...${NC}"
                echo "Keeping: $BACKUP_KEEP_DAILY daily, $BACKUP_KEEP_WEEKLY weekly, $BACKUP_KEEP_MONTHLY monthly"

                # Prune local
                if run_restic "$RESTIC_REPOSITORY" forget \
                    --keep-daily "$BACKUP_KEEP_DAILY" \
                    --keep-weekly "$BACKUP_KEEP_WEEKLY" \
                    --keep-monthly "$BACKUP_KEEP_MONTHLY" \
                    --prune; then
                    echo -e "${GREEN}Local repository pruned${NC}"
                else
                    echo -e "${RED}Local prune failed${NC}"
                    exit 1
                fi

                # Prune offsite (may fail with write-only)
                if [[ -n "$RESTIC_OFFSITE_REPOSITORY" ]]; then
                    echo -e "${YELLOW}Pruning offsite repository...${NC}"
                    if run_restic "$RESTIC_OFFSITE_REPOSITORY" forget \
                        --keep-daily "$BACKUP_KEEP_DAILY" \
                        --keep-weekly "$BACKUP_KEEP_WEEKLY" \
                        --keep-monthly "$BACKUP_KEEP_MONTHLY" \
                        --prune 2>/dev/null; then
                        echo -e "${GREEN}Offsite repository pruned${NC}"
                    else
                        echo -e "${YELLOW}Offsite prune skipped (delete permissions required)${NC}"
                        echo "Use S3 lifecycle rules to expire old offsite backups"
                    fi
                fi
                ;;

            verify)
                echo -e "${YELLOW}Verifying backup repository...${NC}"

                if run_restic "$RESTIC_REPOSITORY" check; then
                    echo -e "${GREEN}Local repository verified${NC}"
                else
                    echo -e "${RED}Local repository has errors${NC}"
                    send_alert "Backup Verify Failed" "Local backup repository verification failed"
                    exit 1
                fi

                # Show recent snapshots
                echo ""
                echo "Recent snapshots:"
                run_restic "$RESTIC_REPOSITORY" snapshots --last 5
                ;;

            auto)
                CRON_OFFSITE=""
                DISABLE=false

                for arg in "${@:2}"; do
                    case "$arg" in
                        --offsite) CRON_OFFSITE="--offsite" ;;
                        --disable) DISABLE=true ;;
                    esac
                done

                CRON_SCRIPT="$SCRIPT_DIR/backups/auto-backup.sh"
                mkdir -p "$SCRIPT_DIR/backups"

                if $DISABLE; then
                    echo -e "${YELLOW}Disabling automatic backups...${NC}"
                    crontab -l 2>/dev/null | grep -v "$CRON_SCRIPT" | crontab -
                    rm -f "$CRON_SCRIPT"
                    echo -e "${GREEN}Automatic backups disabled${NC}"
                else
                    echo -e "${YELLOW}Setting up automatic daily backups...${NC}"

                    cat > "$CRON_SCRIPT" << EOF
#!/bin/bash
cd "$SCRIPT_DIR"
./timetiles backup $CRON_OFFSITE
./timetiles backup prune
EOF
                    chmod +x "$CRON_SCRIPT"

                    # Add to crontab (daily at 2 AM)
                    CRON_CMD="0 2 * * * $CRON_SCRIPT >> /var/log/timetiles-backup.log 2>&1"
                    (crontab -l 2>/dev/null | grep -v "$CRON_SCRIPT"; echo "$CRON_CMD") | crontab -

                    echo -e "${GREEN}Automatic backups configured (daily at 2 AM)${NC}"
                    [[ -n "$CRON_OFFSITE" ]] && echo "Offsite sync enabled"
                    echo "Logs: /var/log/timetiles-backup.log"
                    echo "To disable: timetiles backup auto --disable"
                fi
                ;;

            *)
                echo "Usage: $0 backup [--offsite] [db|uploads|full]"
                echo "       $0 backup list [--offsite]"
                echo "       $0 backup prune"
                echo "       $0 backup verify"
                echo "       $0 backup auto [--offsite] [--disable]"
                echo ""
                echo "Commands:"
                echo "  full      - Backup database and uploads (default)"
                echo "  db        - Backup database only"
                echo "  uploads   - Backup uploads only"
                echo "  list      - List snapshots"
                echo "  prune     - Apply retention policy"
                echo "  verify    - Check repository integrity"
                echo "  auto      - Setup automatic daily backups"
                echo ""
                echo "Options:"
                echo "  --offsite - Also sync to S3 (for backup/auto)"
                echo "            - List from S3 (for list)"
                exit 1
                ;;
        esac
        ;;
        
    restore)
        check_env
        load_restic_config

        SNAPSHOT="${2:-}"
        OFFSITE=false

        # Check for --offsite flag
        for arg in "$@"; do
            [[ "$arg" == "--offsite" ]] && OFFSITE=true
        done

        REPO="$RESTIC_REPOSITORY"
        if $OFFSITE; then
            if [[ -z "$RESTIC_OFFSITE_REPOSITORY" ]]; then
                echo -e "${RED}No offsite repository configured${NC}"
                exit 1
            fi
            REPO="$RESTIC_OFFSITE_REPOSITORY"
            echo -e "${YELLOW}Restoring from offsite repository...${NC}"
            echo -e "${YELLOW}(Requires read permissions)${NC}"
        fi

        # If no snapshot specified, list and prompt
        if [[ -z "$SNAPSHOT" ]] || [[ "$SNAPSHOT" == "--offsite" ]]; then
            echo -e "${YELLOW}Available snapshots:${NC}"
            if ! run_restic "$REPO" snapshots 2>/dev/null; then
                if $OFFSITE; then
                    echo -e "${RED}Cannot list offsite snapshots (read permissions required)${NC}"
                    echo "Use AWS console to find snapshot ID, then run:"
                    echo "  timetiles restore <snapshot-id> --offsite"
                fi
                exit 1
            fi
            echo ""
            echo "Usage: timetiles restore <snapshot-id> [--offsite]"
            echo "       timetiles restore latest [--offsite]"
            exit 0
        fi

        # Handle 'latest' keyword
        if [[ "$SNAPSHOT" == "latest" ]]; then
            SNAPSHOT=$(run_restic "$REPO" snapshots --json --latest 1 2>/dev/null | jq -r '.[0].short_id // empty')
            if [[ -z "$SNAPSHOT" ]]; then
                echo -e "${RED}No snapshots found${NC}"
                exit 1
            fi
            echo "Latest snapshot: $SNAPSHOT"
        fi

        # Get snapshot info
        SNAPSHOT_INFO=$(run_restic "$REPO" snapshots --json "$SNAPSHOT" 2>/dev/null)
        if [[ -z "$SNAPSHOT_INFO" ]] || [[ "$SNAPSHOT_INFO" == "[]" ]]; then
            echo -e "${RED}Snapshot not found: $SNAPSHOT${NC}"
            exit 1
        fi

        TAGS=$(echo "$SNAPSHOT_INFO" | jq -r '.[0].tags // [] | join(",")')
        echo "Snapshot $SNAPSHOT tags: $TAGS"

        # Confirm restore
        echo ""
        echo -e "${YELLOW}WARNING: This will overwrite current data!${NC}"
        read -p "Continue with restore? [y/N] " -n 1 -r
        echo
        [[ ! $REPLY =~ ^[Yy]$ ]] && exit 0

        RESTORE_DIR=$(mktemp -d)
        trap "rm -rf $RESTORE_DIR" EXIT

        # Restore snapshot to temp directory
        echo -e "${YELLOW}Extracting snapshot...${NC}"
        if ! run_restic "$REPO" restore "$SNAPSHOT" --target "$RESTORE_DIR"; then
            echo -e "${RED}Failed to extract snapshot${NC}"
            exit 1
        fi

        # Check what was restored
        if [[ -f "$RESTORE_DIR/database.sql" ]]; then
            echo -e "${YELLOW}Restoring database...${NC}"

            # Restore database
            if ! $DC_CMD exec -T postgres bash -c 'PGPASSWORD=$POSTGRES_PASS psql -h localhost -U $POSTGRES_USER $POSTGRES_DBNAME' < "$RESTORE_DIR/database.sql"; then
                echo -e "${RED}Database restore failed${NC}"
                send_alert "Restore Failed" "Database restore failed at $(date)"
                exit 1
            fi
            echo -e "${GREEN}Database restored${NC}"
        fi

        if [[ -d "$RESTORE_DIR/data" ]]; then
            echo -e "${YELLOW}Restoring uploads...${NC}"

            UPLOAD_VOL=$(docker volume ls -q | grep -E 'timetiles.*uploads' | head -1)
            if [[ -z "$UPLOAD_VOL" ]]; then
                echo -e "${RED}Upload volume not found${NC}"
                exit 1
            fi

            # Restore uploads via docker
            if ! docker run --rm \
                -v "$UPLOAD_VOL:/data" \
                -v "$RESTORE_DIR/data:/restore:ro" \
                alpine sh -c "rm -rf /data/* && cp -a /restore/. /data/"; then
                echo -e "${RED}Uploads restore failed${NC}"
                send_alert "Restore Failed" "Uploads restore failed at $(date)"
                exit 1
            fi
            echo -e "${GREEN}Uploads restored${NC}"
        fi

        echo -e "${GREEN}Restore complete!${NC}"
        ;;
        
    status)
        check_env
        source "$ENV_FILE"
        echo -e "${YELLOW}Checking service status...${NC}"
        echo ""

        # Check PostgreSQL
        echo -n "PostgreSQL: "
        if $DC_CMD exec postgres pg_isready -U "${DB_USER:-timetiles_user}" -d "${DB_NAME:-timetiles}" > /dev/null 2>&1; then
            echo -e "${GREEN}✓ Healthy${NC}"
        else
            echo -e "${RED}✗ Unhealthy${NC}"
        fi

        # Check Web App
        echo -n "Web App: "
        if curl -f -s http://localhost:3000/api/health > /dev/null 2>&1; then
            echo -e "${GREEN}✓ Healthy${NC}"
        else
            echo -e "${RED}✗ Unhealthy${NC}"
        fi

        echo ""
        $DC_CMD ps
        ;;

    check)
        # Comprehensive deployment health check
        # Verifies all bootstrap steps are properly configured
        # Uses shared verification functions from bootstrap/lib/common.sh

        # Source shared verification functions
        BOOTSTRAP_LIB="$SCRIPT_DIR/bootstrap/lib/common.sh"
        if [[ -f "$BOOTSTRAP_LIB" ]]; then
            # Disable trap handler from common.sh (we handle our own exit)
            trap - EXIT INT TERM
            source "$BOOTSTRAP_LIB"
        fi

        ERRORS=0
        WARNINGS=0

        print_ok() { echo -e "${GREEN}✓${NC} $1"; }
        print_warn() { echo -e "${YELLOW}⚠${NC} $1"; WARNINGS=$((WARNINGS + 1)); }
        print_fail() { echo -e "${RED}✗${NC} $1"; ERRORS=$((ERRORS + 1)); }
        print_section() { echo -e "\n${YELLOW}=== $1 ===${NC}"; }

        # Run a verify function and print result
        # Usage: run_check verify_function_name
        run_check() {
            local func="$1"
            if type "$func" &>/dev/null; then
                "$func"
                local result=$?
                case $result in
                    0) print_ok "$CHECK_MSG" ;;
                    1) print_warn "$CHECK_MSG" ;;
                    *) print_fail "$CHECK_MSG" ;;
                esac
            else
                print_warn "Check function not available: $func"
            fi
        }

        # Load env file if exists
        if [[ -f "$ENV_FILE" ]]; then
            source "$ENV_FILE"
        fi

        print_section "System"
        run_check verify_ubuntu
        run_check verify_swap

        print_section "Security"
        run_check verify_ufw
        run_check verify_ssh_hardening
        run_check verify_fail2ban

        print_section "Docker"
        run_check verify_docker
        run_check verify_docker_compose
        run_check verify_docker_group

        print_section "Configuration"

        # Check env file (inline - specific to timetiles)
        if [[ -f "$ENV_FILE" ]]; then
            print_ok "Configuration file exists (.env.production)"

            # Check required vars
            MISSING_VARS=""
            for var in PAYLOAD_SECRET DB_PASSWORD DOMAIN_NAME; do
                val=$(grep "^$var=" "$ENV_FILE" 2>/dev/null | cut -d= -f2-)
                if [[ -z "$val" ]] || [[ "$val" == *"CHANGE_ME"* ]] || [[ "$val" == *"your-domain"* ]]; then
                    MISSING_VARS="${MISSING_VARS:+$MISSING_VARS, }$var"
                fi
            done
            if [[ -z "$MISSING_VARS" ]]; then
                print_ok "Required env vars configured"
            else
                print_fail "Missing/unconfigured vars: $MISSING_VARS"
            fi
        else
            print_fail "Configuration file missing (.env.production)"
        fi

        print_section "Application"

        # Check containers (inline - requires DC_CMD)
        if [[ -f "$ENV_FILE" ]]; then
            for container in postgres web nginx; do
                STATUS=$($DC_CMD ps --format '{{.Status}}' $container 2>/dev/null | head -1)
                if [[ "$STATUS" == *"Up"* ]]; then
                    if [[ "$STATUS" == *"healthy"* ]] || [[ "$container" == "nginx" ]]; then
                        print_ok "$container container healthy"
                    elif [[ "$STATUS" == *"unhealthy"* ]]; then
                        print_fail "$container container unhealthy"
                    else
                        print_ok "$container container running"
                    fi
                else
                    print_fail "$container container not running"
                fi
            done

            # Check health endpoint
            if curl -f -s http://localhost:3000/api/health > /dev/null 2>&1; then
                print_ok "Health endpoint responding"
            else
                print_fail "Health endpoint not responding"
            fi

            # Check database connection
            if $DC_CMD exec -T postgres pg_isready -U "${DB_USER:-timetiles_user}" -d "${DB_NAME:-timetiles}" > /dev/null 2>&1; then
                print_ok "Database connection working"
            else
                print_fail "Database connection failed"
            fi
        else
            print_warn "Skipping container checks (no config)"
        fi

        print_section "SSL"

        # Check SSL certificate (inline - requires DC_CMD and DOMAIN_NAME)
        if [[ -n "$DOMAIN_NAME" ]]; then
            CERT_PATH="/etc/letsencrypt/live/$DOMAIN_NAME/fullchain.pem"
            # Check via docker if volume mounted
            CERT_INFO=$($DC_CMD exec -T nginx openssl x509 -in "$CERT_PATH" -noout -dates -subject 2>/dev/null)
            if [[ -n "$CERT_INFO" ]]; then
                EXPIRY=$(echo "$CERT_INFO" | grep "notAfter" | cut -d= -f2)
                EXPIRY_EPOCH=$(date -d "$EXPIRY" +%s 2>/dev/null || date -j -f "%b %d %T %Y %Z" "$EXPIRY" +%s 2>/dev/null)
                NOW_EPOCH=$(date +%s)
                DAYS_LEFT=$(( (EXPIRY_EPOCH - NOW_EPOCH) / 86400 ))

                if [[ "$DAYS_LEFT" -gt 30 ]]; then
                    print_ok "SSL certificate valid (expires in $DAYS_LEFT days)"
                elif [[ "$DAYS_LEFT" -gt 0 ]]; then
                    print_warn "SSL certificate expiring soon ($DAYS_LEFT days)"
                else
                    print_fail "SSL certificate expired"
                fi
            else
                # Check for self-signed fallback
                if [[ -f "$SCRIPT_DIR/ssl/live/$DOMAIN_NAME/fullchain.pem" ]]; then
                    print_warn "Using self-signed SSL certificate"
                else
                    print_fail "No SSL certificate found"
                fi
            fi
        else
            print_warn "DOMAIN_NAME not set, skipping SSL check"
        fi

        # Check certbot renewal
        if $DC_CMD ps certbot 2>/dev/null | grep -q "Up"; then
            print_ok "Certbot auto-renewal running"
        else
            print_warn "Certbot container not running"
        fi

        print_section "Monitoring"
        run_check verify_backup_cron
        run_check verify_log_rotation
        run_check "verify_alerting $ALERT_SCRIPT"

        # Summary
        echo ""
        echo "======================================"
        if [[ $ERRORS -eq 0 ]] && [[ $WARNINGS -eq 0 ]]; then
            echo -e "${GREEN}ALL CHECKS PASSED${NC}"
            exit 0
        elif [[ $ERRORS -eq 0 ]]; then
            echo -e "${YELLOW}PASSED WITH $WARNINGS WARNING(S)${NC}"
            exit 0
        else
            echo -e "${RED}FAILED: $ERRORS ERROR(S), $WARNINGS WARNING(S)${NC}"
            exit 1
        fi
        ;;
        
    ssl)
        check_env
        init_ssl
        ;;
        
    update)
        check_env
        echo -e "${YELLOW}Updating TimeTiles...${NC}"
        git pull origin main
        if [ -f "$SCRIPT_DIR/docker-compose.override.yml" ]; then
            echo -e "${YELLOW}Rebuilding local images...${NC}"
            $DC_CMD build web
        else
            echo -e "${YELLOW}Pulling latest images from registry...${NC}"
            $DC_CMD pull
        fi
        $DC_CMD up -d --no-deps web
        echo -e "${GREEN}Update complete! Migrations will run automatically.${NC}"
        ;;
        
    *)
        print_usage
        exit 1
        ;;
esac