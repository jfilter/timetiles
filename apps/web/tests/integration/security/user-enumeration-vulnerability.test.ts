// @vitest-environment node
/**
 * Tests for secure user registration that prevents user enumeration.
 *
 * User enumeration is a vulnerability where attackers can determine if an email
 * is registered by observing different responses for existing vs new emails.
 *
 * SECURE BEHAVIOR:
 * - Registration should always return the same response (success + "check your email")
 * - New users: receive verification email
 * - Existing users: receive "someone tried to register with your email" notification
 *
 * @module
 */

import { NextRequest } from "next/server";
import { afterAll, beforeAll, beforeEach, describe, expect, it } from "vitest";

import { POST } from "@/app/api/auth/register/route";
import { resetRateLimitService } from "@/lib/services/rate-limit-service";
import { TEST_CREDENTIALS } from "@/tests/constants/test-credentials";
import { createIntegrationTestEnvironment } from "@/tests/setup/integration/environment";

describe.sequential("User Registration - Enumeration Prevention", () => {
  let payload: any;
  let cleanup: () => Promise<void>;
  let ipCounter = 1;

  // Generate unique IP for each request to avoid rate limiting
  const getUniqueIp = () => `192.168.${Math.floor(ipCounter / 256)}.${ipCounter++ % 256}`;

  beforeAll(async () => {
    const env = await createIntegrationTestEnvironment();
    payload = env.payload;
    cleanup = env.cleanup;
  }, 60000);

  afterAll(async () => {
    await cleanup();
  });

  beforeEach(() => {
    // Reset rate limit service to ensure clean state for each test
    resetRateLimitService();
  });

  describe("Registration should not reveal if email exists", () => {
    it("should succeed for new email", async () => {
      const newEmail = `new-user-${Date.now()}@test.com`;

      const request = new NextRequest("http://localhost:3000/api/auth/register", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-forwarded-for": getUniqueIp(),
        },
        body: JSON.stringify({
          email: newEmail,
          password: TEST_CREDENTIALS.basic.strongPassword,
        }),
      });

      const response = await POST(request);
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.success).toBe(true);
      expect(data.message).toContain("check your email");

      // Cleanup - find and delete the user
      const users = await payload.find({
        collection: "users",
        where: { email: { equals: newEmail.toLowerCase() } },
        overrideAccess: true,
      });
      if (users.docs.length > 0) {
        await payload.delete({
          collection: "users",
          id: users.docs[0].id,
          overrideAccess: true,
        });
      }
    });

    it("should succeed silently for existing email (no error thrown)", async () => {
      // Create existing user directly via Payload
      const existingEmail = `existing-${Date.now()}@test.com`;
      const existingUser = await payload.create({
        collection: "users",
        data: {
          email: existingEmail,
          password: TEST_CREDENTIALS.basic.strongPassword,
          trustLevel: "1",
          role: "user",
        },
        disableVerificationEmail: true,
      });

      // Try to register with same email via API
      const request = new NextRequest("http://localhost:3000/api/auth/register", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-forwarded-for": getUniqueIp(),
        },
        body: JSON.stringify({
          email: existingEmail,
          password: TEST_CREDENTIALS.basic.strongPassword,
        }),
      });

      const response = await POST(request);
      const data = await response.json();

      // SECURE BEHAVIOR: Should return success (same as new email)
      expect(response.status).toBe(200);
      expect(data.success).toBe(true);
      expect(data.message).toContain("check your email");

      // Cleanup
      await payload.delete({
        collection: "users",
        id: existingUser.id,
        overrideAccess: true,
      });
    });

    it("should return identical response structure for new and existing emails", async () => {
      // Create existing user
      const existingEmail = `existing-${Date.now()}@test.com`;
      const existingUser = await payload.create({
        collection: "users",
        data: {
          email: existingEmail,
          password: TEST_CREDENTIALS.basic.strongPassword,
          trustLevel: "1",
          role: "user",
        },
        disableVerificationEmail: true,
      });

      const newEmail = `new-${Date.now()}@test.com`;

      // Register with new email
      const newEmailRequest = new NextRequest("http://localhost:3000/api/auth/register", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-forwarded-for": getUniqueIp(),
        },
        body: JSON.stringify({
          email: newEmail,
          password: TEST_CREDENTIALS.basic.strongPassword,
        }),
      });

      const newEmailResponse = await POST(newEmailRequest);
      const newEmailData = await newEmailResponse.json();

      // Register with existing email
      const existingEmailRequest = new NextRequest("http://localhost:3000/api/auth/register", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-forwarded-for": getUniqueIp(),
        },
        body: JSON.stringify({
          email: existingEmail,
          password: TEST_CREDENTIALS.basic.strongPassword,
        }),
      });

      const existingEmailResponse = await POST(existingEmailRequest);
      const existingEmailData = await existingEmailResponse.json();

      // SECURE BEHAVIOR: Both should have identical response structure
      expect(newEmailResponse.status).toBe(existingEmailResponse.status);
      expect(newEmailData.success).toBe(existingEmailData.success);
      expect(newEmailData.message).toBe(existingEmailData.message);

      // Both should be successful
      expect(newEmailData.success).toBe(true);
      expect(existingEmailData.success).toBe(true);

      // Cleanup
      await payload.delete({
        collection: "users",
        id: existingUser.id,
        overrideAccess: true,
      });

      // Cleanup new user
      const newUsers = await payload.find({
        collection: "users",
        where: { email: { equals: newEmail.toLowerCase() } },
        overrideAccess: true,
      });
      if (newUsers.docs.length > 0) {
        await payload.delete({
          collection: "users",
          id: newUsers.docs[0].id,
          overrideAccess: true,
        });
      }
    });
  });

  describe("Input validation", () => {
    it("should reject invalid email addresses", async () => {
      const request = new NextRequest("http://localhost:3000/api/auth/register", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-forwarded-for": getUniqueIp(),
        },
        body: JSON.stringify({
          email: "not-an-email",
          password: TEST_CREDENTIALS.basic.strongPassword,
        }),
      });

      const response = await POST(request);
      const data = await response.json();

      expect(response.status).toBe(400);
      expect(data.error).toContain("email");
    });

    it("should reject short passwords", async () => {
      const request = new NextRequest("http://localhost:3000/api/auth/register", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-forwarded-for": getUniqueIp(),
        },
        body: JSON.stringify({
          email: "test@example.com",
          password: "short",
        }),
      });

      const response = await POST(request);
      const data = await response.json();

      expect(response.status).toBe(400);
      expect(data.error).toContain("8 characters");
    });
  });

  describe("Rate limiting", () => {
    it("should enforce rate limits on registration attempts", async () => {
      const sameIp = getUniqueIp();
      const results = [];

      // Make 4 rapid requests from the same IP (limit is 3 per minute)
      for (let i = 0; i < 4; i++) {
        const request = new NextRequest("http://localhost:3000/api/auth/register", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "x-forwarded-for": sameIp,
          },
          body: JSON.stringify({
            email: `ratelimit-${i}-${Date.now()}@test.com`,
            password: TEST_CREDENTIALS.basic.strongPassword,
          }),
        });

        const response = await POST(request);
        const data = await response.json();
        results.push({ status: response.status, data });
      }

      // First 3 should succeed
      expect(results[0]?.status).toBe(200);
      expect(results[1]?.status).toBe(200);
      expect(results[2]?.status).toBe(200);

      // Fourth should be rate limited
      expect(results[3]?.status).toBe(429);
      expect(results[3]?.data.error).toContain("Too many");

      // Cleanup created users
      for (let i = 0; i < 3; i++) {
        const users = await payload.find({
          collection: "users",
          where: { email: { contains: `ratelimit-${i}-` } },
          overrideAccess: true,
        });
        for (const user of users.docs) {
          await payload.delete({
            collection: "users",
            id: user.id,
            overrideAccess: true,
          });
        }
      }
    });
  });
});
