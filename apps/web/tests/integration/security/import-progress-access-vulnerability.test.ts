// @vitest-environment node
/**
 * Security vulnerability tests for Import Progress API endpoint.
 *
 * These tests demonstrate CRITICAL vulnerabilities in the import progress endpoint
 * where ANY user can access ANY import's progress, errors, and metadata without
 * ownership verification.
 *
 * **Expected Status**: ALL VULNERABILITY TESTS SHOULD FAIL
 *
 * This allows:
 * - Cross-user access to import details
 * - Exposure of file names, error messages
 * - Privacy violations and information disclosure
 *
 * Related Issue: security-access-control-remediation-plan.md #1.4
 *
 * @module
 */

import fs from "fs";
import { afterAll, beforeAll, describe, expect, it } from "vitest";

import type { Catalog, ImportFile, User } from "@/payload-types";
import { createIntegrationTestEnvironment } from "@/tests/setup/test-environment-builder";
import { createImportFileWithUpload } from "@/tests/setup/test-helpers";

describe.sequential("Import Progress API Access Control Vulnerabilities", () => {
  let payload: any;
  let cleanup: () => Promise<void>;

  let ownerUser: User;
  let otherUser: User;

  let ownerCatalog: Catalog;
  let ownerImport: ImportFile;

  beforeAll(async () => {
    const env = await createIntegrationTestEnvironment();
    payload = env.payload;
    cleanup = env.cleanup;

    // Ensure upload directory exists
    const uploadDir = process.env.UPLOAD_DIR_IMPORT_FILES ?? "/tmp/import-files";
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
    }

    // Create users
    ownerUser = await payload.create({
      collection: "users",
      data: {
        email: "owner@import-progress-test.com",
        password: "owner123",
        role: "user",
      },
    });

    otherUser = await payload.create({
      collection: "users",
      data: {
        email: "other@import-progress-test.com",
        password: "other123",
        role: "user",
      },
    });

    // Create catalog and import for owner
    ownerCatalog = await payload.create({
      collection: "catalogs",
      data: {
        name: "Owner's Private Catalog",
        isPublic: false,
      },
      user: ownerUser,
    });

    // Create import file with sensitive information
    const csvContent = "confidential_data,business_secret\nvalue1,secret123\nvalue2,secret456";
    ownerImport = await createImportFileWithUpload(
      payload,
      {
        catalog: ownerCatalog.id,
        user: ownerUser.id,
        status: "schema_detected",
        // Add some error messages that might contain sensitive info
      },
      csvContent,
      "confidential-business-data.csv",
      "text/csv"
    );

    // Wait for hooks
    await new Promise((resolve) => setTimeout(resolve, 1000));
    await payload.jobs.run({ allQueues: true, limit: 10 });
  }, 60000);

  afterAll(async () => {
    await cleanup();
  });

  describe("Baseline: Collection Access Controls Work", () => {
    it("should prevent other user from accessing import via collection", async () => {
      await expect(
        payload.findByID({
          collection: "import-files",
          id: ownerImport.id,
          user: otherUser,
          overrideAccess: false,
        })
      ).rejects.toThrow();
    });

    it("should allow owner to access their own import", async () => {
      const importFile = await payload.findByID({
        collection: "import-files",
        id: ownerImport.id,
        user: ownerUser,
        overrideAccess: false,
      });

      expect(importFile.id).toBe(ownerImport.id);
    });
  });

  describe("Vulnerability: /api/import/[id]/progress Bypasses Access Control", () => {
    it("should FAIL: other user cannot access owner's import progress", async () => {
      // Simulate API endpoint call by directly querying without proper auth
      // The actual API endpoint at /api/import/[importId]/progress does NOT check ownership

      // What the API currently does (NO ownership check):
      const apiSimulation = await payload.findByID({
        collection: "import-files",
        id: ownerImport.id,
        // âŒ VULNERABILITY: API doesn't pass user context
        overrideAccess: true, // API effectively does this
      });

      // âŒ FAILS: Should throw/return null, but returns data
      expect(apiSimulation).toBeNull();

      if (apiSimulation) {
        console.warn("ðŸš¨ CRITICAL: Import progress API exposes private import!");
        console.warn(`   otherUser can access: ${apiSimulation.filename}`);
        console.warn(`   Catalog: ${typeof apiSimulation.catalog === "object" ? apiSimulation.catalog.id : apiSimulation.catalog}`);

        if (apiSimulation.errorMessage) {
          console.warn(`   Error message exposed: ${apiSimulation.errorMessage}`);
        }
      }
    });

    it("should FAIL: other user cannot see import file names", async () => {
      // File names might contain sensitive information
      const apiSimulation = await payload.findByID({
        collection: "import-files",
        id: ownerImport.id,
        overrideAccess: true, // What API does
      });

      // âŒ FAILS: Should not expose filename
      expect(apiSimulation).toBeNull();

      if (apiSimulation?.filename) {
        console.warn("ðŸš¨ SECURITY ISSUE: Filename exposed to unauthorized user");
        console.warn(`   Filename: ${apiSimulation.filename}`);

        if (apiSimulation.filename.includes("confidential") || apiSimulation.filename.includes("secret")) {
          console.warn("   ðŸ”´ CRITICAL: Filename suggests sensitive data!");
        }
      }
    });

    it("should FAIL: other user cannot see import error messages", async () => {
      // Update import with error message
      await payload.update({
        collection: "import-files",
        id: ownerImport.id,
        data: {
          status: "failed",
          errorMessage: "Database connection failed: postgres://user:password@internal-db.company.com/prod",
        },
        overrideAccess: true,
      });

      // Simulate API access
      const apiSimulation = await payload.findByID({
        collection: "import-files",
        id: ownerImport.id,
        overrideAccess: true,
      });

      // âŒ FAILS: Should not expose error message
      expect(apiSimulation?.errorMessage).toBeUndefined();

      if (apiSimulation?.errorMessage) {
        console.warn("ðŸš¨ CRITICAL: Error message exposed!");
        console.warn(`   Error: ${apiSimulation.errorMessage}`);

        if (apiSimulation.errorMessage.includes("password") || apiSimulation.errorMessage.includes("://")) {
          console.warn("   ðŸ”´ CRITICAL: Error contains credentials/URLs!");
        }
      }
    });

    it("should FAIL: other user cannot see import job details", async () => {
      // Create import job
      const job = await payload.create({
        collection: "import-jobs",
        data: {
          importFile: ownerImport.id,
          stage: "processing",
          progress: {
            current: 50,
            total: 100,
          },
          metadata: {
            sensitiveInfo: "Internal processing details",
          },
        },
        user: ownerUser,
      });

      // API would fetch jobs for this import
      const jobsSimulation = await payload.find({
        collection: "import-jobs",
        where: { importFile: { equals: ownerImport.id } },
        // âŒ No user context
        overrideAccess: true,
      });

      // âŒ FAILS: Should return empty
      expect(jobsSimulation.docs).toHaveLength(0);

      if (jobsSimulation.docs.length > 0) {
        console.warn("ðŸš¨ CRITICAL: Import job details exposed!");
        console.warn(`   Jobs exposed: ${jobsSimulation.docs.length}`);
        jobsSimulation.docs.forEach((j: any) => {
          console.warn(`   - Stage: ${j.stage}, Progress: ${j.progress?.current}/${j.progress?.total}`);
        });
      }
    });

    it("should FAIL: unauthenticated users cannot access import progress", async () => {
      // Simulate unauthenticated API call
      const unauthSimulation = await payload.findByID({
        collection: "import-files",
        id: ownerImport.id,
        // No user
        overrideAccess: true, // API doesn't enforce auth
      });

      // âŒ FAILS: Should be null for unauthenticated
      expect(unauthSimulation).toBeNull();

      if (unauthSimulation) {
        console.warn("ðŸš¨ CRITICAL: Unauthenticated access to import progress!");
        console.warn(`   Import ID ${ownerImport.id} accessible without auth`);
      }
    });
  });

  describe("Vulnerability: Progress API Exposes Catalog Information", () => {
    it("should FAIL: cannot determine if import belongs to private catalog", async () => {
      const apiSimulation = await payload.findByID({
        collection: "import-files",
        id: ownerImport.id,
        overrideAccess: true,
        depth: 1, // API might populate relationships
      });

      expect(apiSimulation).toBeNull();

      if (apiSimulation && typeof apiSimulation.catalog === "object") {
        console.warn("ðŸš¨ SECURITY ISSUE: Catalog information exposed!");
        console.warn(`   Catalog name: ${apiSimulation.catalog.name}`);
        console.warn(`   Catalog public: ${apiSimulation.catalog.isPublic}`);

        if (!apiSimulation.catalog.isPublic) {
          console.warn("   ðŸ”´ CRITICAL: Reveals private catalog details!");
        }
      }
    });
  });

  describe("Vulnerability: Import Enumeration", () => {
    it("should FAIL: cannot enumerate imports by trying sequential IDs", async () => {
      // Attacker could try IDs 1, 2, 3, ... to find valid imports
      const importId = ownerImport.id;

      // Try to access without auth
      const apiSimulation = await payload.findByID({
        collection: "import-files",
        id: importId,
        overrideAccess: true,
      });

      // âŒ FAILS: Should return null/401, not reveal existence
      expect(apiSimulation).toBeNull();

      if (apiSimulation) {
        console.warn("ðŸš¨ SECURITY ISSUE: Import enumeration possible!");
        console.warn(`   ID ${importId} reveals import exists`);
        console.warn(`   Attacker can enumerate all imports by trying IDs`);
      }
    });
  });

  describe("Expected Behavior After Fix", () => {
    it("should enforce ownership check at API level", async () => {
      // Proper implementation should check ownership
      try {
        await payload.findByID({
          collection: "import-files",
          id: ownerImport.id,
          user: otherUser, // â† User context provided
          overrideAccess: false, // â† Access control enforced
        });
        throw new Error("Should have been denied");
      } catch (error) {
        // Expected - access denied
        expect(error).toBeDefined();
      }
    });

    it("should return 404 for non-existent or unauthorized imports", async () => {
      // API should return same error for both cases to prevent enumeration
      const fakeId = "non-existent-id";

      try {
        await payload.findByID({
          collection: "import-files",
          id: fakeId,
          user: otherUser,
          overrideAccess: false,
        });
      } catch (error) {
        // Should get same error as unauthorized access
        expect(error).toBeDefined();
      }
    });

    it("should allow owner to access their import progress", async () => {
      const result = await payload.findByID({
        collection: "import-files",
        id: ownerImport.id,
        user: ownerUser,
        overrideAccess: false,
      });

      expect(result.id).toBe(ownerImport.id);
      expect(result.filename).toBeDefined();
    });
  });
});
