// @vitest-environment node
/**
 * Security vulnerability tests for Users collection access controls.
 *
 * These tests demonstrate CRITICAL security vulnerabilities in the users collection
 * where access controls are set to `() => true`, allowing:
 * - Anyone to read all users (including emails, roles, trust levels)
 * - Anyone to create users with admin role
 * - Anyone to modify other users' data including role escalation
 * - Anyone to delete user accounts
 *
 * **Expected Status**: ALL TESTS SHOULD FAIL (demonstrating vulnerabilities)
 *
 * Related Issue: security-access-control-remediation-plan.md #1.1
 *
 * @module
 */

import { afterAll, beforeAll, describe, expect, it } from "vitest";

import type { User } from "@/payload-types";
import { createIntegrationTestEnvironment } from "@/tests/setup/test-environment-builder";

describe.sequential("Users Collection Security Vulnerabilities", () => {
  let payload: any;
  let cleanup: () => Promise<void>;

  let regularUserA: User;
  let regularUserB: User;
  let adminUser: User;

  beforeAll(async () => {
    const env = await createIntegrationTestEnvironment();
    payload = env.payload;
    cleanup = env.cleanup;

    // Create test users
    regularUserA = await payload.create({
      collection: "users",
      data: {
        email: "user-a@security-test.com",
        password: "password123",
        role: "user",
      },
    });

    regularUserB = await payload.create({
      collection: "users",
      data: {
        email: "user-b@security-test.com",
        password: "password123",
        role: "user",
      },
    });

    adminUser = await payload.create({
      collection: "users",
      data: {
        email: "admin@security-test.com",
        password: "admin123",
        role: "admin",
      },
    });
  }, 60000);

  afterAll(async () => {
    await cleanup();
  });

  describe("Vulnerability #1: Users Can Read Other Users' Data", () => {
    it("should FAIL: regular user can read other users' email addresses", async () => {
      // UserA tries to read UserB's profile
      const result = await payload.find({
        collection: "users",
        where: { id: { equals: regularUserB.id } },
        user: regularUserA,
        overrideAccess: false,
      });

      // VULNERABILITY: This should return empty but returns the user
      expect(result.docs).toHaveLength(0); // ❌ FAILS - actually returns 1

      if (result.docs.length > 0) {
        console.warn("🚨 SECURITY ISSUE: User can read other users' data");
        console.warn(`   UserA (${regularUserA.id}) accessed UserB (${regularUserB.id})`);
        console.warn(`   Exposed email: ${result.docs[0].email}`);
      }
    });

    it("should FAIL: regular user can list all users in the system", async () => {
      const result = await payload.find({
        collection: "users",
        user: regularUserA,
        overrideAccess: false,
      });

      // VULNERABILITY: Should only see their own profile
      expect(result.docs).toHaveLength(1); // ❌ FAILS - returns all users
      expect(result.docs.every((u: User) => u.id === regularUserA.id)).toBe(true);

      if (result.docs.length > 1) {
        console.warn("🚨 SECURITY ISSUE: User can list all system users");
        console.warn(`   UserA can see ${result.docs.length} users:`);
        result.docs.forEach((u: User) => {
          console.warn(`   - ${u.email} (${u.role})`);
        });
      }
    });

    it("should FAIL: unauthenticated user cannot read any users", async () => {
      const result = await payload.find({
        collection: "users",
        overrideAccess: false,
      });

      // VULNERABILITY: Should be empty for unauthenticated
      expect(result.docs).toHaveLength(0); // ❌ FAILS - returns all users

      if (result.docs.length > 0) {
        console.warn("🚨 CRITICAL: Unauthenticated access to user data!");
        console.warn(`   ${result.docs.length} users exposed to public`);
      }
    });
  });

  describe("Vulnerability #2: Anyone Can Create Admin Accounts", () => {
    it("should FAIL: regular user cannot create admin accounts", async () => {
      await expect(
        payload.create({
          collection: "users",
          data: {
            email: "evil-admin@security-test.com",
            password: "hacked123",
            role: "admin", // ← Attempting privilege escalation
          },
          user: regularUserA,
          overrideAccess: false,
        })
      ).rejects.toThrow(); // ❌ FAILS - creation succeeds

      // Verify it wasn't created
      const check = await payload.find({
        collection: "users",
        where: { email: { equals: "evil-admin@security-test.com" } },
        overrideAccess: true,
      });

      if (check.docs.length > 0) {
        console.warn("🚨 CRITICAL: Regular user created admin account!");
        console.warn(`   New admin: ${check.docs[0].email}`);
      }
    });

    it("should FAIL: unauthenticated user cannot create accounts", async () => {
      await expect(
        payload.create({
          collection: "users",
          data: {
            email: "anon-user@security-test.com",
            password: "anon123",
            role: "user",
          },
          overrideAccess: false,
        })
      ).rejects.toThrow(); // ❌ FAILS - creation succeeds

      const check = await payload.find({
        collection: "users",
        where: { email: { equals: "anon-user@security-test.com" } },
        overrideAccess: true,
      });

      if (check.docs.length > 0) {
        console.warn("🚨 SECURITY ISSUE: Unauthenticated user registration allowed");
      }
    });
  });

  describe("Vulnerability #3: Users Can Elevate Their Own Privileges", () => {
    it("should FAIL: regular user cannot change their own role to admin", async () => {
      await expect(
        payload.update({
          collection: "users",
          id: regularUserA.id,
          data: { role: "admin" }, // ← Self privilege escalation
          user: regularUserA,
          overrideAccess: false,
        })
      ).rejects.toThrow(); // ❌ FAILS - update succeeds

      // Verify role wasn't changed
      const updated = await payload.findByID({
        collection: "users",
        id: regularUserA.id,
        overrideAccess: true,
      });

      expect(updated.role).toBe("user");

      if (updated.role === "admin") {
        console.warn("🚨 CRITICAL: User escalated their own privileges!");
        console.warn(`   ${regularUserA.email} is now admin`);
      }
    });
  });

  describe("Vulnerability #4: Users Can Modify Other Users' Data", () => {
    it("should FAIL: regular user cannot update another user's profile", async () => {
      await expect(
        payload.update({
          collection: "users",
          id: regularUserB.id,
          data: { email: "hacked@evil.com" },
          user: regularUserA,
          overrideAccess: false,
        })
      ).rejects.toThrow(); // ❌ FAILS - update succeeds

      // Verify it wasn't changed
      const check = await payload.findByID({
        collection: "users",
        id: regularUserB.id,
        overrideAccess: true,
      });

      expect(check.email).toBe(regularUserB.email);

      if (check.email === "hacked@evil.com") {
        console.warn("🚨 CRITICAL: User modified another user's account!");
        console.warn(`   UserA changed UserB's email`);
      }
    });

    it("should FAIL: regular user cannot change another user's role", async () => {
      await expect(
        payload.update({
          collection: "users",
          id: regularUserB.id,
          data: { role: "admin" }, // ← Escalating other user
          user: regularUserA,
          overrideAccess: false,
        })
      ).rejects.toThrow(); // ❌ FAILS - update succeeds

      const check = await payload.findByID({
        collection: "users",
        id: regularUserB.id,
        overrideAccess: true,
      });

      if (check.role === "admin") {
        console.warn("🚨 CRITICAL: User escalated another user's privileges!");
      }
    });
  });

  describe("Vulnerability #5: Users Can Delete Other Users", () => {
    it("should FAIL: regular user cannot delete another user", async () => {
      // Create temporary user to delete
      const tempUser = await payload.create({
        collection: "users",
        data: {
          email: "temp@security-test.com",
          password: "temp123",
          role: "user",
        },
      });

      await expect(
        payload.delete({
          collection: "users",
          id: tempUser.id,
          user: regularUserA,
          overrideAccess: false,
        })
      ).rejects.toThrow(); // ❌ FAILS - deletion succeeds

      // Verify user still exists
      try {
        await payload.findByID({
          collection: "users",
          id: tempUser.id,
          overrideAccess: true,
        });
      } catch {
        console.warn("🚨 CRITICAL: User deleted another user's account!");
      }
    });

    it("should FAIL: regular user cannot delete admin account", async () => {
      await expect(
        payload.delete({
          collection: "users",
          id: adminUser.id,
          user: regularUserA,
          overrideAccess: false,
        })
      ).rejects.toThrow(); // ❌ FAILS - deletion succeeds

      try {
        await payload.findByID({
          collection: "users",
          id: adminUser.id,
          overrideAccess: true,
        });
      } catch {
        console.warn("🚨 CRITICAL: Regular user deleted admin account!");
      }
    });
  });

  describe("Valid Operations (Should Pass)", () => {
    it("should allow user to read their own profile", async () => {
      const result = await payload.findByID({
        collection: "users",
        id: regularUserA.id,
        user: regularUserA,
        overrideAccess: false,
      });

      expect(result.id).toBe(regularUserA.id);
      expect(result.email).toBe(regularUserA.email);
    });

    it("should allow user to update their own non-sensitive fields", async () => {
      const updated = await payload.update({
        collection: "users",
        id: regularUserA.id,
        data: { name: "Updated Name" },
        user: regularUserA,
        overrideAccess: false,
      });

      expect(updated.name).toBe("Updated Name");
    });

    it("should allow admin to manage all users", async () => {
      // Admin can read any user
      const userB = await payload.findByID({
        collection: "users",
        id: regularUserB.id,
        user: adminUser,
        overrideAccess: false,
      });
      expect(userB.id).toBe(regularUserB.id);

      // Admin can update any user
      const updated = await payload.update({
        collection: "users",
        id: regularUserB.id,
        data: { name: "Admin Updated" },
        user: adminUser,
        overrideAccess: false,
      });
      expect(updated.name).toBe("Admin Updated");
    });
  });
});
