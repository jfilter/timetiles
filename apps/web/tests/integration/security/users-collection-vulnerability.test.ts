// @vitest-environment node
/**
 * Security vulnerability tests for Users collection access controls.
 *
 * These tests demonstrate CRITICAL security vulnerabilities in the users collection
 * where access controls are set to `() => true`, allowing:
 * - Anyone to read all users (including emails, roles, trust levels)
 * - Anyone to create users with admin role
 * - Anyone to modify other users' data including role escalation
 * - Anyone to delete user accounts
 *
 * **Expected Status**: ALL TESTS SHOULD FAIL (demonstrating vulnerabilities)
 *
 * Related Issue: security-access-control-remediation-plan.md #1.1
 *
 * @module
 */

import { afterAll, beforeAll, describe, expect, it } from "vitest";

import type { User } from "@/payload-types";
import { createIntegrationTestEnvironment, withUsers } from "@/tests/setup/integration/environment";

describe.sequential("Users Collection Security Vulnerabilities", () => {
  let payload: any;
  let cleanup: () => Promise<void>;

  let regularUserA: User;
  let regularUserB: User;
  let adminUser: User;

  beforeAll(async () => {
    const env = await createIntegrationTestEnvironment();
    payload = env.payload;
    cleanup = env.cleanup;

    // Create test users using withUsers helper
    const { users } = await withUsers(env, {
      admin: { role: "admin" },
      userA: { role: "user" },
      userB: { role: "user" },
    });
    adminUser = users.admin;
    regularUserA = users.userA;
    regularUserB = users.userB;
  }, 60000);

  afterAll(async () => {
    await cleanup();
  });

  describe("Vulnerability #1: Users Can Read Other Users' Data", () => {
    it("should FAIL: regular user can read other users' email addresses", async () => {
      // UserA tries to read UserB's profile
      const result = await payload.find({
        collection: "users",
        where: { id: { equals: regularUserB.id } },
        user: regularUserA,
        overrideAccess: false,
      });

      // VULNERABILITY: This should return empty but returns the user
      expect(result.docs).toHaveLength(0); // âŒ FAILS - actually returns 1

      if (result.docs.length > 0) {
        console.warn("ðŸš¨ SECURITY ISSUE: User can read other users' data");
        console.warn(`   UserA (${regularUserA.id}) accessed UserB (${regularUserB.id})`);
        console.warn(`   Exposed email: ${result.docs[0].email}`);
      }
    });

    it("should FAIL: regular user can list all users in the system", async () => {
      const result = await payload.find({
        collection: "users",
        user: regularUserA,
        overrideAccess: false,
      });

      // VULNERABILITY: Should only see their own profile
      expect(result.docs).toHaveLength(1); // âŒ FAILS - returns all users
      expect(result.docs.every((u: User) => u.id === regularUserA.id)).toBe(true);

      if (result.docs.length > 1) {
        console.warn("ðŸš¨ SECURITY ISSUE: User can list all system users");
        console.warn(`   UserA can see ${result.docs.length} users:`);
        result.docs.forEach((u: User) => {
          console.warn(`   - ${u.email} (${u.role})`);
        });
      }
    });

    it("should prevent unauthenticated user from reading any users", async () => {
      // âœ… FIXED: Now properly throws error for unauthenticated access
      await expect(
        payload.find({
          collection: "users",
          overrideAccess: false,
        })
      ).rejects.toThrow(/Forbidden|not allowed/i);
    });
  });

  describe("Vulnerability #2: Anyone Can Create Admin Accounts", () => {
    it("should FAIL: regular user cannot create admin accounts", async () => {
      await expect(
        payload.create({
          collection: "users",
          data: {
            email: "evil-admin@security-test.com",
            password: "hacked123",
            role: "admin", // â† Attempting privilege escalation
          },
          user: regularUserA,
          overrideAccess: false,
        })
      ).rejects.toThrow(); // âŒ FAILS - creation succeeds

      // Verify it wasn't created
      const check = await payload.find({
        collection: "users",
        where: { email: { equals: "evil-admin@security-test.com" } },
        overrideAccess: true,
      });

      if (check.docs.length > 0) {
        console.warn("ðŸš¨ CRITICAL: Regular user created admin account!");
        console.warn(`   New admin: ${check.docs[0].email}`);
      }
    });

    it("should allow local API user creation (for tests/seeding) but with forced role=user via beforeChange hook", async () => {
      // NOTE: Local API calls (payload.create) are intentionally allowed for tests and seeding.
      // The security restriction for self-registration only applies to REST API requests.
      // The beforeChange hook forces role=user for REST API self-registration.
      // See users.ts lines 319-336 for the security logic.

      const result = await payload.create({
        collection: "users",
        data: {
          email: "local-api-user@security-test.com",
          password: "localapi123",
          role: "user",
        },
        overrideAccess: false,
        disableVerificationEmail: true,
      });

      // Local API creation should succeed (needed for tests and seeding)
      expect(result.id).toBeDefined();
      expect(result.email).toBe("local-api-user@security-test.com");

      // Cleanup
      await payload.delete({
        collection: "users",
        id: result.id,
        overrideAccess: true,
      });
    });
  });

  describe("Vulnerability #3: Users Can Elevate Their Own Privileges", () => {
    it("should FAIL: regular user cannot change their own role to admin", async () => {
      await expect(
        payload.update({
          collection: "users",
          id: regularUserA.id,
          data: { role: "admin" }, // â† Self privilege escalation
          user: regularUserA,
          overrideAccess: false,
        })
      ).rejects.toThrow(); // âŒ FAILS - update succeeds

      // Verify role wasn't changed
      const updated = await payload.findByID({
        collection: "users",
        id: regularUserA.id,
        overrideAccess: true,
      });

      expect(updated.role).toBe("user");

      if (updated.role === "admin") {
        console.warn("ðŸš¨ CRITICAL: User escalated their own privileges!");
        console.warn(`   ${regularUserA.email} is now admin`);
      }
    });
  });

  describe("Vulnerability #4: Users Can Modify Other Users' Data", () => {
    it("should FAIL: regular user cannot update another user's profile", async () => {
      await expect(
        payload.update({
          collection: "users",
          id: regularUserB.id,
          data: { email: "hacked@evil.com" },
          user: regularUserA,
          overrideAccess: false,
        })
      ).rejects.toThrow(); // âŒ FAILS - update succeeds

      // Verify it wasn't changed
      const check = await payload.findByID({
        collection: "users",
        id: regularUserB.id,
        overrideAccess: true,
      });

      expect(check.email).toBe(regularUserB.email);

      if (check.email === "hacked@evil.com") {
        console.warn("ðŸš¨ CRITICAL: User modified another user's account!");
        console.warn(`   UserA changed UserB's email`);
      }
    });

    it("should FAIL: regular user cannot change another user's role", async () => {
      await expect(
        payload.update({
          collection: "users",
          id: regularUserB.id,
          data: { role: "admin" }, // â† Escalating other user
          user: regularUserA,
          overrideAccess: false,
        })
      ).rejects.toThrow(); // âŒ FAILS - update succeeds

      const check = await payload.findByID({
        collection: "users",
        id: regularUserB.id,
        overrideAccess: true,
      });

      if (check.role === "admin") {
        console.warn("ðŸš¨ CRITICAL: User escalated another user's privileges!");
      }
    });
  });

  describe("Vulnerability #5: Users Can Delete Other Users", () => {
    it("should FAIL: regular user cannot delete another user", async () => {
      // Create temporary user to delete
      const tempUser = await payload.create({
        collection: "users",
        data: {
          email: "temp@security-test.com",
          password: "temp123",
          role: "user",
        },
        disableVerificationEmail: true,
      });

      await expect(
        payload.delete({
          collection: "users",
          id: tempUser.id,
          user: regularUserA,
          overrideAccess: false,
        })
      ).rejects.toThrow(); // âŒ FAILS - deletion succeeds

      // Verify user still exists
      try {
        await payload.findByID({
          collection: "users",
          id: tempUser.id,
          overrideAccess: true,
        });
      } catch {
        console.warn("ðŸš¨ CRITICAL: User deleted another user's account!");
      }
    });

    it("should FAIL: regular user cannot delete admin account", async () => {
      await expect(
        payload.delete({
          collection: "users",
          id: adminUser.id,
          user: regularUserA,
          overrideAccess: false,
        })
      ).rejects.toThrow(); // âŒ FAILS - deletion succeeds

      try {
        await payload.findByID({
          collection: "users",
          id: adminUser.id,
          overrideAccess: true,
        });
      } catch {
        console.warn("ðŸš¨ CRITICAL: Regular user deleted admin account!");
      }
    });
  });

  describe("Valid Operations (Should Pass)", () => {
    it("should allow user to read their own profile", async () => {
      const result = await payload.findByID({
        collection: "users",
        id: regularUserA.id,
        user: regularUserA,
        overrideAccess: false,
      });

      expect(result.id).toBe(regularUserA.id);
      expect(result.email).toBe(regularUserA.email);
    });

    it("should allow user to update their own non-sensitive fields", async () => {
      const updated = await payload.update({
        collection: "users",
        id: regularUserA.id,
        data: { firstName: "Updated" },
        user: regularUserA,
        overrideAccess: false,
      });

      expect(updated.firstName).toBe("Updated");
    });

    it("should allow admin to manage all users", async () => {
      // Admin can read any user
      const userB = await payload.findByID({
        collection: "users",
        id: regularUserB.id,
        user: adminUser,
        overrideAccess: false,
      });
      expect(userB.id).toBe(regularUserB.id);

      // Admin can update any user
      const updated = await payload.update({
        collection: "users",
        id: regularUserB.id,
        data: { firstName: "AdminUpdated" },
        user: adminUser,
        overrideAccess: false,
      });
      expect(updated.firstName).toBe("AdminUpdated");
    });
  });
});
