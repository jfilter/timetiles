// @vitest-environment node
/**
 * Security vulnerability tests for Scheduled Imports access control.
 *
 * These tests demonstrate CRITICAL vulnerabilities in scheduled-imports collection
 * where access controls only check `Boolean(user)`, allowing ANY authenticated user
 * to read and modify ANY scheduled import, including:
 * - Viewing other users' webhook tokens
 * - Modifying import URLs and credentials
 * - Accessing authentication settings
 * - Changing catalog associations
 *
 * **Expected Status**: ALL VULNERABILITY TESTS SHOULD FAIL
 *
 * Related Issue: security-access-control-remediation-plan.md #1.6
 *
 * @module
 */

import { afterAll, beforeAll, describe, expect, it } from "vitest";

import type { Catalog, ScheduledImport, User } from "@/payload-types";
import { createIntegrationTestEnvironment } from "@/tests/setup/test-environment-builder";

describe.sequential("Scheduled Imports Access Control Vulnerabilities", () => {
  let payload: any;
  let cleanup: () => Promise<void>;

  let ownerUser: User;
  let otherUser: User;
  let adminUser: User;

  let ownerCatalog: Catalog;
  let ownerSchedule: ScheduledImport;

  beforeAll(async () => {
    const env = await createIntegrationTestEnvironment();
    payload = env.payload;
    cleanup = env.cleanup;

    // Create test users
    ownerUser = await payload.create({
      collection: "users",
      data: {
        email: "owner@schedule-test.com",
        password: "owner123",
        role: "user",
      },
    });

    otherUser = await payload.create({
      collection: "users",
      data: {
        email: "other@schedule-test.com",
        password: "other123",
        role: "user",
      },
    });

    adminUser = await payload.create({
      collection: "users",
      data: {
        email: "admin@schedule-test.com",
        password: "admin123",
        role: "admin",
      },
    });

    // Create catalog owned by ownerUser
    ownerCatalog = await payload.create({
      collection: "catalogs",
      data: {
        name: "Owner's Catalog",
        isPublic: false,
      },
      user: ownerUser,
    });

    // Create scheduled import owned by ownerUser
    ownerSchedule = await payload.create({
      collection: "scheduled-imports",
      data: {
        name: "Owner's Scheduled Import",
        sourceUrl: "https://example.com/owner-data.csv",
        catalog: ownerCatalog.id,
        scheduleType: "frequency",
        frequency: "daily",
        enabled: true,
        webhookEnabled: true,
        // Webhook token would be auto-generated
      },
      user: ownerUser,
    });
  }, 60000);

  afterAll(async () => {
    await cleanup();
  });

  describe("Vulnerability: Any User Can Read Any Scheduled Import", () => {
    it("should FAIL: other user cannot read owner's scheduled import", async () => {
      const result = await payload.find({
        collection: "scheduled-imports",
        where: { id: { equals: ownerSchedule.id } },
        user: otherUser,
        overrideAccess: false,
      });

      // ❌ FAILS: Should return empty, but returns the schedule
      expect(result.docs).toHaveLength(0);

      if (result.docs.length > 0) {
        console.warn("🚨 CRITICAL: User accessed another user's scheduled import!");
        console.warn(`   otherUser can see: ${result.docs[0].name}`);
        console.warn(`   URL exposed: ${result.docs[0].sourceUrl}`);

        if (result.docs[0].webhookToken) {
          console.warn(`   🔴 WEBHOOK TOKEN EXPOSED: ${result.docs[0].webhookToken}`);
        }
      }
    });

    it("should FAIL: other user cannot read owner's webhook token", async () => {
      const schedule = await payload.findByID({
        collection: "scheduled-imports",
        id: ownerSchedule.id,
        user: ownerUser,
        overrideAccess: false,
      });

      // Verify webhook token exists
      expect(schedule.webhookToken).toBeDefined();

      // Other user tries to access
      await expect(
        payload.findByID({
          collection: "scheduled-imports",
          id: ownerSchedule.id,
          user: otherUser,
          overrideAccess: false,
        })
      ).rejects.toThrow(); // ❌ FAILS: Access succeeds

      // If it doesn't throw, check what was returned
      try {
        const otherUserView = await payload.findByID({
          collection: "scheduled-imports",
          id: ownerSchedule.id,
          user: otherUser,
          overrideAccess: false,
        });

        if (otherUserView.webhookToken) {
          console.warn("🚨 CRITICAL: Webhook token exposed to unauthorized user!");
          console.warn(`   Token: ${otherUserView.webhookToken.substring(0, 20)}...`);
        }
      } catch {
        // Expected - access denied
      }
    });

    it("should FAIL: other user cannot list all scheduled imports", async () => {
      // Create another schedule for otherUser
      const otherCatalog = await payload.create({
        collection: "catalogs",
        data: {
          name: "Other's Catalog",
          isPublic: false,
        },
        user: otherUser,
      });

      await payload.create({
        collection: "scheduled-imports",
        data: {
          name: "Other's Schedule",
          sourceUrl: "https://example.com/other-data.csv",
          catalog: otherCatalog.id,
          scheduleType: "frequency",
          frequency: "weekly",
          enabled: false,
        },
        user: otherUser,
      });

      const result = await payload.find({
        collection: "scheduled-imports",
        user: otherUser,
        overrideAccess: false,
      });

      // ❌ FAILS: Should only see their own schedule (1), not both (2)
      expect(result.docs).toHaveLength(1);
      expect(result.docs.every((s: ScheduledImport) => s.name === "Other's Schedule")).toBe(true);

      if (result.docs.length > 1) {
        console.warn("🚨 CRITICAL: User can see all scheduled imports!");
        console.warn(`   otherUser sees ${result.docs.length} schedules:`);
        result.docs.forEach((s: ScheduledImport) => {
          console.warn(`   - ${s.name} (${s.sourceUrl})`);
        });
      }
    });
  });

  describe("Vulnerability: Any User Can Modify Any Scheduled Import", () => {
    it("should FAIL: other user cannot update owner's scheduled import", async () => {
      await expect(
        payload.update({
          collection: "scheduled-imports",
          id: ownerSchedule.id,
          data: {
            sourceUrl: "https://evil.com/malicious-data.csv",
          },
          user: otherUser,
          overrideAccess: false,
        })
      ).rejects.toThrow(); // ❌ FAILS: Update succeeds

      // Verify it wasn't changed
      const check = await payload.findByID({
        collection: "scheduled-imports",
        id: ownerSchedule.id,
        overrideAccess: true,
      });

      expect(check.sourceUrl).toBe(ownerSchedule.sourceUrl);

      if (check.sourceUrl === "https://evil.com/malicious-data.csv") {
        console.warn("🚨 CRITICAL: User modified another user's scheduled import!");
        console.warn(`   Changed URL from ${ownerSchedule.sourceUrl}`);
        console.warn(`   Changed URL to ${check.sourceUrl}`);
      }
    });

    it("should FAIL: other user cannot change owner's schedule settings", async () => {
      await expect(
        payload.update({
          collection: "scheduled-imports",
          id: ownerSchedule.id,
          data: {
            enabled: false, // Disable owner's schedule
            frequency: "monthly", // Change frequency
          },
          user: otherUser,
          overrideAccess: false,
        })
      ).rejects.toThrow(); // ❌ FAILS: Update succeeds

      const check = await payload.findByID({
        collection: "scheduled-imports",
        id: ownerSchedule.id,
        overrideAccess: true,
      });

      expect(check.enabled).toBe(ownerSchedule.enabled);

      if (!check.enabled && ownerSchedule.enabled) {
        console.warn("🚨 CRITICAL: User disabled another user's scheduled import!");
      }
    });

    it("should FAIL: other user cannot change catalog association", async () => {
      // Create catalog for otherUser
      const maliciousCatalog = await payload.create({
        collection: "catalogs",
        data: {
          name: "Malicious Catalog",
          isPublic: false,
        },
        user: otherUser,
      });

      await expect(
        payload.update({
          collection: "scheduled-imports",
          id: ownerSchedule.id,
          data: {
            catalog: maliciousCatalog.id, // Redirect to their catalog
          },
          user: otherUser,
          overrideAccess: false,
        })
      ).rejects.toThrow(); // ❌ FAILS: Update succeeds

      const check = await payload.findByID({
        collection: "scheduled-imports",
        id: ownerSchedule.id,
        overrideAccess: true,
      });

      const checkCatalogId = typeof check.catalog === "object" ? check.catalog.id : check.catalog;

      expect(checkCatalogId).toBe(ownerCatalog.id);

      if (checkCatalogId === maliciousCatalog.id) {
        console.warn("🚨 CRITICAL: User hijacked scheduled import to their catalog!");
      }
    });
  });

  describe("Vulnerability: Authentication Configuration Exposure", () => {
    it("should FAIL: other user cannot view basic auth credentials", async () => {
      // Update schedule with basic auth
      await payload.update({
        collection: "scheduled-imports",
        id: ownerSchedule.id,
        data: {
          authenticationType: "basic",
          basicAuth: {
            username: "admin",
            password: "super-secret-password",
          },
        },
        user: ownerUser,
      });

      // Other user tries to read
      await expect(
        payload.findByID({
          collection: "scheduled-imports",
          id: ownerSchedule.id,
          user: otherUser,
          overrideAccess: false,
        })
      ).rejects.toThrow(); // ❌ FAILS: Access succeeds

      try {
        const otherView = await payload.findByID({
          collection: "scheduled-imports",
          id: ownerSchedule.id,
          user: otherUser,
          overrideAccess: false,
        });

        if (otherView.basicAuth?.password) {
          console.warn("🚨 CRITICAL: Basic auth password exposed!");
          console.warn(`   Password: ${otherView.basicAuth.password}`);
        }
      } catch {
        // Expected
      }
    });

    it("should FAIL: other user cannot view bearer token", async () => {
      await payload.update({
        collection: "scheduled-imports",
        id: ownerSchedule.id,
        data: {
          authenticationType: "bearer",
          bearerToken: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.secret-token",
        },
        user: ownerUser,
      });

      await expect(
        payload.findByID({
          collection: "scheduled-imports",
          id: ownerSchedule.id,
          user: otherUser,
          overrideAccess: false,
        })
      ).rejects.toThrow(); // ❌ FAILS

      try {
        const otherView = await payload.findByID({
          collection: "scheduled-imports",
          id: ownerSchedule.id,
          user: otherUser,
          overrideAccess: false,
        });

        if (otherView.bearerToken) {
          console.warn("🚨 CRITICAL: Bearer token exposed!");
          console.warn(`   Token: ${otherView.bearerToken.substring(0, 30)}...`);
        }
      } catch {
        // Expected
      }
    });
  });

  describe("Valid Operations (Should Pass)", () => {
    it("should allow owner to read their own scheduled import", async () => {
      const schedule = await payload.findByID({
        collection: "scheduled-imports",
        id: ownerSchedule.id,
        user: ownerUser,
        overrideAccess: false,
      });

      expect(schedule.id).toBe(ownerSchedule.id);
      expect(schedule.name).toBe(ownerSchedule.name);
    });

    it("should allow owner to update their own scheduled import", async () => {
      const updated = await payload.update({
        collection: "scheduled-imports",
        id: ownerSchedule.id,
        data: {
          name: "Updated Name",
        },
        user: ownerUser,
        overrideAccess: false,
      });

      expect(updated.name).toBe("Updated Name");
    });

    it("should allow admin to access all scheduled imports", async () => {
      const schedule = await payload.findByID({
        collection: "scheduled-imports",
        id: ownerSchedule.id,
        user: adminUser,
        overrideAccess: false,
      });

      expect(schedule.id).toBe(ownerSchedule.id);

      const updated = await payload.update({
        collection: "scheduled-imports",
        id: ownerSchedule.id,
        data: {
          name: "Admin Updated",
        },
        user: adminUser,
        overrideAccess: false,
      });

      expect(updated.name).toBe("Admin Updated");
    });
  });
});
