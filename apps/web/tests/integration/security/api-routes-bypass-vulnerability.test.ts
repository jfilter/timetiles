// @vitest-environment node
/**
 * Security vulnerability tests for API routes bypassing access controls.
 *
 * These tests demonstrate CRITICAL vulnerabilities where Next.js API routes
 * directly query collections without passing user context, completely bypassing
 * the carefully designed collection-level access controls.
 *
 * **Expected Status**: ALL VULNERABILITY TESTS SHOULD FAIL
 *
 * The tests verify that:
 * - Unauthenticated users can access private catalog data
 * - Users can see events from catalogs they don't own
 * - API routes expose data that collection queries would hide
 *
 * Related Issue: security-access-control-remediation-plan.md #1.2
 *
 * @module
 */

import { afterAll, beforeAll, describe, expect, it } from "vitest";

import type { Catalog, Dataset, Event, User } from "@/payload-types";
import { createIntegrationTestEnvironment } from "@/tests/setup/test-environment-builder";

describe.sequential("API Routes Access Control Bypass Vulnerabilities", () => {
  let payload: any;
  let cleanup: () => Promise<void>;

  let ownerUser: User;
  let otherUser: User;

  let privateCatalog: Catalog;
  let publicCatalog: Catalog;
  let privateDataset: Dataset;
  let publicDataset: Dataset;
  let privateEvent: Event;
  let publicEvent: Event;

  beforeAll(async () => {
    const env = await createIntegrationTestEnvironment();
    payload = env.payload;
    cleanup = env.cleanup;

    // Create users
    ownerUser = await payload.create({
      collection: "users",
      data: {
        email: "owner@api-security-test.com",
        password: "owner123",
        role: "user",
      },
    });

    otherUser = await payload.create({
      collection: "users",
      data: {
        email: "other@api-security-test.com",
        password: "other123",
        role: "user",
      },
    });

    // Create PRIVATE catalog with event (should NOT be publicly accessible)
    privateCatalog = await payload.create({
      collection: "catalogs",
      data: {
        name: "Private Catalog - Should Be Hidden",
        isPublic: false,
      },
      user: ownerUser,
    });

    privateDataset = await payload.create({
      collection: "datasets",
      data: {
        name: "Private Dataset",
        catalog: privateCatalog.id,
        language: "eng",
        isPublic: false,
      },
      user: ownerUser,
    });

    privateEvent = await payload.create({
      collection: "events",
      data: {
        dataset: privateDataset.id,
        data: { title: "PRIVATE EVENT - SHOULD BE HIDDEN" },
        uniqueId: `${privateDataset.id}:test:private-event`,
        location: {
          type: "Point",
          coordinates: [-122.4, 37.8], // SF area
        },
      },
      user: ownerUser,
    });

    // Create PUBLIC catalog with event (should be publicly accessible)
    publicCatalog = await payload.create({
      collection: "catalogs",
      data: {
        name: "Public Catalog",
        isPublic: true,
      },
      user: ownerUser,
    });

    publicDataset = await payload.create({
      collection: "datasets",
      data: {
        name: "Public Dataset",
        catalog: publicCatalog.id,
        language: "eng",
        isPublic: true,
      },
      user: ownerUser,
    });

    publicEvent = await payload.create({
      collection: "events",
      data: {
        dataset: publicDataset.id,
        data: { title: "Public Event" },
        uniqueId: `${publicDataset.id}:test:public-event`,
        location: {
          type: "Point",
          coordinates: [-122.3, 37.7], // SF area
        },
      },
      user: ownerUser,
    });
  }, 60000);

  afterAll(async () => {
    await cleanup();
  });

  describe("Baseline: Collection Access Controls Work Correctly", () => {
    it("should prevent other user from accessing private catalog via collection", async () => {
      const result = await payload.find({
        collection: "catalogs",
        where: { id: { equals: privateCatalog.id } },
        user: otherUser,
        overrideAccess: false,
      });

      // Collection access control WORKS - no access to private catalog
      expect(result.docs).toHaveLength(0);
    });

    it("should prevent other user from accessing private events via collection", async () => {
      await expect(
        payload.findByID({
          collection: "events",
          id: privateEvent.id,
          user: otherUser,
          overrideAccess: false,
        })
      ).rejects.toThrow();
    });

    it("should allow access to public events via collection", async () => {
      const event = await payload.findByID({
        collection: "events",
        id: publicEvent.id,
        user: otherUser,
        overrideAccess: false,
      });

      expect(event.id).toBe(publicEvent.id);
    });
  });

  describe("Vulnerability: /api/events/list Bypasses Access Controls", () => {
    it("should FAIL: API returns private events without user context", async () => {
      // Direct Payload query WITH access control enforcement
      const payloadResult = await payload.find({
        collection: "events",
        where: {
          id: { in: [privateEvent.id, publicEvent.id] },
        },
        user: otherUser, // ← User context provided
        overrideAccess: false,
      });

      // Should only see public event
      expect(payloadResult.docs).toHaveLength(1);
      expect(payloadResult.docs[0].id).toBe(publicEvent.id);

      // Simulate what the API route does (WITHOUT user context)
      const apiSimulation = await payload.find({
        collection: "events",
        where: {
          id: { in: [privateEvent.id, publicEvent.id] },
        },
        // ❌ VULNERABILITY: No user context passed
        // overrideAccess defaults to true in API routes
      });

      // ❌ FAILS: API exposes private event
      expect(apiSimulation.docs).toHaveLength(1); // Should be 1 (public only)
      expect(apiSimulation.docs.some((e: Event) => e.id === privateEvent.id)).toBe(false);

      if (apiSimulation.docs.some((e: Event) => e.id === privateEvent.id)) {
        console.warn("🚨 CRITICAL: /api/events/list exposes private events!");
        const title = typeof privateEvent.data === "object" && privateEvent.data !== null ? (privateEvent.data as any).title : "unknown";
        console.warn(`   Private event "${title}" is accessible`);
        console.warn(`   From private catalog: ${privateCatalog.name}`);
      }
    });

    it("should FAIL: API allows listing all events without authentication", async () => {
      // With access control (no user)
      const controlledResult = await payload.find({
        collection: "events",
        user: undefined, // No authentication
        overrideAccess: false,
      });

      // Should only see public events
      const hasPrivate = controlledResult.docs.some((e: Event) => e.id === privateEvent.id);
      expect(hasPrivate).toBe(false);

      // Simulate API route behavior (no user context)
      const apiSimulation = await payload.find({
        collection: "events",
        // ❌ No user, no overrideAccess: false
      });

      // ❌ FAILS: Exposes all events
      const apiHasPrivate = apiSimulation.docs.some((e: Event) => e.id === privateEvent.id);
      expect(apiHasPrivate).toBe(false);

      if (apiHasPrivate) {
        console.warn("🚨 CRITICAL: Unauthenticated API access to private events!");
        console.warn(`   Total events exposed: ${apiSimulation.docs.length}`);
      }
    });
  });

  describe("Vulnerability: /api/events/map-clusters Bypasses Access Controls", () => {
    it("should FAIL: map-clusters API exposes private events in bounding box", async () => {
      // Bounding box covering San Francisco (where our test events are)
      const bounds = {
        north: 37.9,
        south: 37.6,
        east: -122.2,
        west: -122.5,
      };

      // Simulate the map-clusters query WITHOUT user context
      // In reality, this uses a PostGIS function, but we can test with find
      const apiSimulation = await payload.find({
        collection: "events",
        where: {
          location: {
            near: {
              coordinates: [-122.35, 37.75],
              maxDistance: 50000, // 50km
            },
          },
        },
        // ❌ VULNERABILITY: No user context
      });

      // ❌ FAILS: Should not include private event
      const hasPrivateEvent = apiSimulation.docs.some((e: Event) => e.id === privateEvent.id);
      expect(hasPrivateEvent).toBe(false);

      if (hasPrivateEvent) {
        console.warn("🚨 CRITICAL: map-clusters exposes private event locations!");
        console.warn(`   Private event coordinates exposed: ${JSON.stringify(privateEvent.location)}`);
      }
    });
  });

  describe("Vulnerability: /api/events/histogram Bypasses Access Controls", () => {
    it("should FAIL: histogram API includes private events in counts", async () => {
      // Query with access control
      const controlledResult = await payload.find({
        collection: "events",
        user: otherUser,
        overrideAccess: false,
      });

      const controlledCount = controlledResult.docs.length;

      // Simulate histogram API (no user context)
      const apiSimulation = await payload.find({
        collection: "events",
        // ❌ No user context
      });

      const apiCount = apiSimulation.docs.length;

      // ❌ FAILS: Counts should match (only public events)
      expect(apiCount).toBe(controlledCount);

      if (apiCount > controlledCount) {
        console.warn("🚨 CRITICAL: histogram includes private events in statistics!");
        console.warn(`   Controlled count: ${controlledCount}, API count: ${apiCount}`);
        console.warn(`   Leaking existence of ${apiCount - controlledCount} private events`);
      }
    });
  });

  describe("Expected Behavior After Fix", () => {
    it("should only return events from accessible catalogs when user context is provided", async () => {
      // This demonstrates what the API SHOULD do
      const properResult = await payload.find({
        collection: "events",
        user: otherUser,
        overrideAccess: false,
      });

      // Should only see public event
      expect(properResult.docs).toHaveLength(1);
      expect(properResult.docs[0].id).toBe(publicEvent.id);

      // Should NOT see private event
      const hasPrivate = properResult.docs.some((e: Event) => e.id === privateEvent.id);
      expect(hasPrivate).toBe(false);
    });

    it("should return empty results for unauthenticated users when no public catalogs", async () => {
      // Make the public catalog private
      await payload.update({
        collection: "catalogs",
        id: publicCatalog.id,
        data: { isPublic: false },
        user: ownerUser,
      });

      // Query without user (unauthenticated)
      const result = await payload.find({
        collection: "events",
        user: undefined,
        overrideAccess: false,
      });

      // Should see no events
      expect(result.docs).toHaveLength(0);

      // Restore public status
      await payload.update({
        collection: "catalogs",
        id: publicCatalog.id,
        data: { isPublic: true },
        user: ownerUser,
      });
    });
  });
});
