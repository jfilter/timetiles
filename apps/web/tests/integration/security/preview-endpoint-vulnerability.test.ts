// @vitest-environment node
/**
 * Security vulnerability tests for Preview endpoint authentication.
 *
 * These tests demonstrate CRITICAL vulnerabilities in the preview endpoint where:
 * 1. Authentication lookup uses JWT cookie VALUE as user ID instead of validating JWT
 * 2. Shared preview secret can be reused by anyone who obtains it
 * 3. No user-specific token validation
 *
 * **Expected Status**: ALL VULNERABILITY TESTS SHOULD FAIL
 *
 * Related Issue: security-access-control-remediation-plan.md #1.6
 *
 * @module
 */

import { afterAll, beforeAll, describe, expect, it } from "vitest";

import type { User } from "@/payload-types";
import { createIntegrationTestEnvironment } from "@/tests/setup/test-environment-builder";

describe.sequential("Preview Endpoint Authentication Vulnerabilities", () => {
  let payload: any;
  let cleanup: () => Promise<void>;

  let userA: User;
  let userB: User;

  beforeAll(async () => {
    const env = await createIntegrationTestEnvironment();
    payload = env.payload;
    cleanup = env.cleanup;

    userA = await payload.create({
      collection: "users",
      data: {
        email: "user-a@preview-test.com",
        password: "password123",
        role: "user",
      },
    });

    userB = await payload.create({
      collection: "users",
      data: {
        email: "user-b@preview-test.com",
        password: "password123",
        role: "user",
      },
    });
  }, 60000);

  afterAll(async () => {
    await cleanup();
  });

  describe("FIXED: JWT Authentication Now Uses Proper Validation", () => {
    it("should properly validate JWT tokens using payload.auth()", async () => {
      // Generate a real JWT for userA
      const token = await payload.login({
        collection: "users",
        data: {
          email: userA.email,
          password: "password123",
        },
      });

      // âœ… FIXED: Now uses correct JWT validation via payload.auth()
      // (Previously tried to lookup user by JWT string which always failed)
      const { user } = await payload.auth({
        headers: new Headers({
          Authorization: `Bearer ${token.token}`,
        }),
      });

      // Verify correct user is authenticated
      expect(user).toBeDefined();
      expect(user?.id).toBe(userA.id);
      expect(user?.email).toBe(userA.email);
    });

    it("should reject invalid JWT tokens", async () => {
      const invalidToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.fake.token";

      // Should properly reject invalid JWT
      const { user } = await payload.auth({
        headers: new Headers({
          Authorization: `Bearer ${invalidToken}`,
        }),
      });

      // Invalid token should not authenticate
      expect(user).toBeNull();
    });
  });

  describe("Vulnerability: Shared Preview Secret", () => {
    it("should FAIL: preview secret can be reused indefinitely", async () => {
      const sharedSecret = process.env.PAYLOAD_PREVIEW_SECRET;

      // Secret never expires, never changes
      // Once someone has it, they can use it forever

      expect(sharedSecret).toBeUndefined(); // Should not have global secret

      if (sharedSecret) {
        console.warn("ðŸš¨ SECURITY ISSUE: Preview secret has no expiration!");
        console.warn("   Secret can be reused indefinitely");
        console.warn("   No time-based validation");
        console.warn("   No revocation mechanism");
      }
    });
  });
});
