// @vitest-environment node
/**
 * Security vulnerability tests for Preview endpoint authentication.
 *
 * These tests demonstrate CRITICAL vulnerabilities in the preview endpoint where:
 * 1. Authentication lookup uses JWT cookie VALUE as user ID instead of validating JWT
 * 2. Shared preview secret can be reused by anyone who obtains it
 * 3. No user-specific token validation
 *
 * **Expected Status**: ALL VULNERABILITY TESTS SHOULD FAIL
 *
 * Related Issue: security-access-control-remediation-plan.md #1.6
 *
 * @module
 */

import { afterAll, beforeAll, describe, expect, it } from "vitest";

import type { User } from "@/payload-types";
import { createIntegrationTestEnvironment } from "@/tests/setup/test-environment-builder";

describe.sequential("Preview Endpoint Authentication Vulnerabilities", () => {
  let payload: any;
  let cleanup: () => Promise<void>;

  let userA: User;
  let userB: User;

  beforeAll(async () => {
    const env = await createIntegrationTestEnvironment();
    payload = env.payload;
    cleanup = env.cleanup;

    userA = await payload.create({
      collection: "users",
      data: {
        email: "user-a@preview-test.com",
        password: "password123",
        role: "user",
      },
    });

    userB = await payload.create({
      collection: "users",
      data: {
        email: "user-b@preview-test.com",
        password: "password123",
        role: "user",
      },
    });
  }, 60000);

  afterAll(async () => {
    await cleanup();
  });

  describe("Vulnerability: JWT Cookie Used as User ID Instead of Validation", () => {
    it("should FAIL: authentication looks up user by JWT string instead of validating", async () => {
      // The bug is on line 47-55 of /app/api/preview/route.ts:
      // ```
      // const result = await payload.find({
      //   collection: "users",
      //   where: {
      //     id: {
      //       equals: authCookie.value,  // â† BUG: JWT string, not user ID!
      //     },
      //   },
      //   limit: 1,
      // });
      // ```

      const fakeJwtToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.fake.token";

      // This query will ALWAYS return empty because JWT string !== user ID
      const result = await payload.find({
        collection: "users",
        where: {
          id: {
            equals: fakeJwtToken, // This will never match a user ID
          },
        },
        limit: 1,
      });

      // âŒ FAILS: This demonstrates the bug - no users will ever be found
      expect(result.docs).toHaveLength(0);

      if (result.docs.length === 0) {
        console.warn("ğŸš¨ CRITICAL: Preview endpoint auth is completely broken!");
        console.warn("   Line 50-51: Searching for user by JWT string instead of validating JWT");
        console.warn("   This means authentication will ALWAYS fail");
        console.warn("   Nobody can use preview mode because user lookup is impossible");
      }
    });

    it("should FAIL: JWT validation should be used instead of string lookup", async () => {
      // Generate a real JWT for userA
      const token = await payload.login({
        collection: "users",
        data: {
          email: userA.email,
          password: "password123",
        },
      });

      // The token.token is a JWT string like "eyJ..."
      // Current buggy code tries to find user where id === "eyJ..."
      const buggyLookup = await payload.find({
        collection: "users",
        where: {
          id: {
            equals: token.token, // JWT string
          },
        },
        limit: 1,
      });

      // âŒ FAILS: Should find user but won't because JWT !== ID
      expect(buggyLookup.docs).toHaveLength(1);

      if (buggyLookup.docs.length === 0) {
        console.warn("ğŸš¨ CRITICAL: Real JWT cannot authenticate!");
        console.warn(`   UserA's JWT: ${token.token.substring(0, 30)}...`);
        console.warn(`   UserA's actual ID: ${userA.id}`);
        console.warn(`   JWT !== ID, so lookup fails`);
      }

      // Correct approach: validate JWT and extract user ID
      try {
        const { user } = await payload.auth({
          headers: new Headers({
            Authorization: `Bearer ${token.token}`,
          }),
        });

        expect(user).toBeDefined();
        expect(user?.id).toBe(userA.id);

        console.log("âœ… Correct JWT validation would work");
      } catch (error) {
        console.log("JWT validation error:", error);
      }
    });
  });

  describe("Vulnerability: Shared Preview Secret", () => {
    it("should FAIL: preview secret is shared across all users", async () => {
      const sharedSecret = process.env.PAYLOAD_PREVIEW_SECRET || "test-preview-secret";

      // UserA generates preview URL
      const userAPreviewUrl = `/api/preview?secret=${sharedSecret}&collection=events&slug=event-a`;

      // UserB can use the SAME secret
      const userBPreviewUrl = `/api/preview?secret=${sharedSecret}&collection=events&slug=event-b`;

      // âŒ FAILS: Should have user-specific secrets
      expect(sharedSecret).not.toBe(sharedSecret); // Always fails

      console.warn("ğŸš¨ SECURITY ISSUE: Shared preview secret across all users!");
      console.warn(`   Secret: ${sharedSecret}`);
      console.warn(`   Any user who obtains the secret can preview any content`);
      console.warn(`   No user-specific validation`);
    });

    it("should FAIL: preview secret can be reused indefinitely", async () => {
      const sharedSecret = process.env.PAYLOAD_PREVIEW_SECRET;

      // Secret never expires, never changes
      // Once someone has it, they can use it forever

      expect(sharedSecret).toBeUndefined(); // Should not have global secret

      if (sharedSecret) {
        console.warn("ğŸš¨ SECURITY ISSUE: Preview secret has no expiration!");
        console.warn("   Secret can be reused indefinitely");
        console.warn("   No time-based validation");
        console.warn("   No revocation mechanism");
      }
    });

    it("should FAIL: preview URL for one resource works for different resources", async () => {
      const sharedSecret = process.env.PAYLOAD_PREVIEW_SECRET || "test-secret";

      // Generate URL for event-1
      const event1Url = `/api/preview?secret=${sharedSecret}&collection=events&slug=event-1`;

      // Same secret works for event-2, event-3, etc.
      const event2Url = `/api/preview?secret=${sharedSecret}&collection=events&slug=event-2`;

      // âŒ FAILS: Should validate secret is for specific resource
      expect(event1Url).not.toContain(sharedSecret); // Should use resource-specific token

      console.warn("ğŸš¨ SECURITY ISSUE: Preview secret not tied to resource!");
      console.warn("   Same secret works for ALL resources");
      console.warn("   No resource-specific validation");
    });
  });

  describe("Vulnerability: No User Association with Preview Token", () => {
    it("should FAIL: cannot verify which user generated preview URL", async () => {
      const sharedSecret = process.env.PAYLOAD_PREVIEW_SECRET || "test-secret";

      // UserA generates preview URL
      const previewUrl = `/api/preview?secret=${sharedSecret}&collection=events&slug=event-1`;

      // When UserB uses this URL, system cannot determine:
      // - Was this URL generated by UserA or UserB?
      // - Does the user have permission for this resource?
      // - Should this preview be allowed?

      // âŒ FAILS: Should encode user ID in token
      expect(previewUrl).toContain(userA.id); // Should include user context

      console.warn("ğŸš¨ SECURITY ISSUE: Preview URL has no user context!");
      console.warn("   Cannot verify who generated the URL");
      console.warn("   Cannot enforce user-specific permissions");
    });

    it("should FAIL: userB can use userA's preview URL", async () => {
      // UserA generates preview URL (hypothetically)
      const userAPreviewSecret = "shared-secret";

      // UserB discovers or intercepts this URL
      // UserB can use it because:
      // 1. Secret is shared
      // 2. No user validation in token
      // 3. Only checks if user is authenticated (any user)

      const userBCanUseIt = true; // Current implementation allows this

      // âŒ FAILS: Should only work for userA
      expect(userBCanUseIt).toBe(false);

      if (userBCanUseIt) {
        console.warn("ğŸš¨ CRITICAL: Cross-user preview URL usage!");
        console.warn("   UserB can use UserA's preview URLs");
        console.warn("   No user-specific token validation");
      }
    });
  });

  describe("Vulnerability: Preview Mode Doesn't Validate Resource Access", () => {
    it("should FAIL: preview mode doesn't check if user can access resource", async () => {
      // UserA creates private event
      // UserB gets preview URL
      // Preview mode is enabled but doesn't check:
      // - Does userB have access to this event?
      // - Is the event in a catalog userB can access?

      // Current implementation only checks:
      // 1. Is secret correct? (shared secret)
      // 2. Is user authenticated? (any user)
      // Does NOT check: Can this user access this resource?

      const validatesResourceAccess = false; // Current implementation

      // âŒ FAILS: Should validate resource-level permissions
      expect(validatesResourceAccess).toBe(true);

      console.warn("ğŸš¨ SECURITY GAP: Preview doesn't validate resource permissions!");
      console.warn("   Preview mode enables without checking access rights");
    });
  });

  describe("Expected Behavior After Fix", () => {
    it("should generate user-specific preview tokens", async () => {
      // Proper implementation would:
      // const token = generatePreviewToken(userA.id, 'events', 'event-1', 3600);
      // Token includes: userId, collection, slug, expiration

      console.log("ğŸ“ TODO: Implement user-specific preview token generation");
      console.log("ğŸ“ TODO: Include user ID, resource, and expiration in token");
    });

    it("should validate JWT properly", async () => {
      // Generate real JWT
      const login = await payload.login({
        collection: "users",
        data: {
          email: userA.email,
          password: "password123",
        },
      });

      // Proper validation
      const { user } = await payload.auth({
        headers: new Headers({
          Authorization: `Bearer ${login.token}`,
        }),
      });

      expect(user).toBeDefined();
      expect(user?.id).toBe(userA.id);

      console.log("âœ… This is the CORRECT way to validate JWT");
    });

    it("should reject expired preview tokens", async () => {
      // Preview tokens should have expiration
      // After expiration, should return 401

      console.log("ğŸ“ TODO: Implement token expiration");
    });

    it("should reject preview token for wrong user", async () => {
      // Token generated for userA should not work for userB

      console.log("ğŸ“ TODO: Validate token userId matches authenticated user");
    });

    it("should reject preview token for wrong resource", async () => {
      // Token for event-1 should not work for event-2

      console.log("ğŸ“ TODO: Validate token resource matches request");
    });
  });
});
