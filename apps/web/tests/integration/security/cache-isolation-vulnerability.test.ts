// @vitest-environment node
/**
 * Security tests verifying URL fetch cache user isolation.
 *
 * These tests verify that the URL fetch cache properly isolates data between users
 * by including userId in cache keys, preventing cross-user data leakage.
 *
 * **Expected Status**: ALL TESTS SHOULD PASS
 *
 * This verifies:
 * - User A's cached data is NOT served to User B
 * - Cache keys include user context
 * - User-specific cache invalidation works correctly
 *
 * Related Issue: security-access-control-remediation-plan.md #1.3
 *
 * @module
 */

import type { IncomingMessage, ServerResponse } from "node:http";

import { afterAll, afterEach, beforeAll, describe, expect, it } from "vitest";

import { getUrlFetchCache } from "@/lib/services/cache/url-fetch-cache";
import type { User } from "@/payload-types";
import { createIntegrationTestEnvironment, withTestServer, withUsers } from "@/tests/setup/integration/environment";

const urlFetchCache = getUrlFetchCache();

describe.sequential("URL Fetch Cache User Isolation", () => {
  let cleanup: () => Promise<void>;

  let userA: User;
  let userB: User;

  let testServer: any;
  let serverUrl: string;

  beforeAll(async () => {
    // Clear cache to ensure clean state (test isolation)
    await urlFetchCache.clear();

    const testEnv = await createIntegrationTestEnvironment();
    const envWithServer = await withTestServer(testEnv);
    cleanup = envWithServer.cleanup;
    testServer = envWithServer.testServer;
    serverUrl = envWithServer.testServerUrl;

    // Create test users
    const { users } = await withUsers(envWithServer, {
      userA: { role: "user" },
      userB: { role: "user" },
    });
    userA = users.userA;
    userB = users.userB;
  }, 60000);

  afterEach(async () => {
    // Clear cache between tests
    await urlFetchCache.clear();
  });

  afterAll(async () => {
    await urlFetchCache.clear(); // Clear cache after all tests (test isolation)
    await cleanup();
  });

  describe("Fix Verified: Cache Keys Include User Context", () => {
    it("should serve different data to different users for same URL", async () => {
      // Set up server to track requests and return user-specific data
      let requestCount = 0;
      const routePath = `/user-data-${Date.now()}.csv`; // Unique path per test
      testServer.route(routePath, (_req: IncomingMessage, res: ServerResponse) => {
        requestCount++;
        res.writeHead(200, {
          "Content-Type": "text/csv",
          "Cache-Control": "max-age=3600",
        });
        res.end(`Request ${requestCount}\nid,name\n${requestCount},Data${requestCount}`);
      });

      const testUrl = `${serverUrl}${routePath}`;

      // UserA fetches data
      const responseA = await urlFetchCache.fetch(testUrl, { userId: userA.id.toString() });
      const dataA = responseA.data.toString();
      expect(dataA).toContain("Request 1");
      expect(dataA).toContain("Data1");
      expect(requestCount).toBe(1);

      // UserB fetches the SAME URL
      // With user-isolated cache, this should make a NEW fetch (different cache key)
      const responseB = await urlFetchCache.fetch(testUrl, { userId: userB.id.toString() });
      const dataB = responseB.data.toString();
      expect(dataB).toContain("Request 2"); // Different data!
      expect(dataB).toContain("Data2");
      expect(requestCount).toBe(2); // ✅ Made second fetch

      // Verify they got different data
      expect(dataA).not.toEqual(dataB);
    });

    it("should cache separately for authenticated vs anonymous users", async () => {
      let requestCount = 0;
      const routePath = `/public-data-${Date.now()}.json`;
      testServer.route(routePath, (_req: IncomingMessage, res: ServerResponse) => {
        requestCount++;
        res.writeHead(200, { "Content-Type": "application/json" });
        res.end(JSON.stringify({ request: requestCount, data: `Response ${requestCount}` }));
      });

      const testUrl = `${serverUrl}${routePath}`;

      // Authenticated user fetches
      const authResponse = await urlFetchCache.fetch(testUrl, { userId: userA.id.toString() });
      expect(JSON.parse(authResponse.data.toString()).request).toBe(1);
      expect(requestCount).toBe(1);

      // Anonymous user fetches same URL (no userId)
      // Should use different cache key and make new fetch
      const anonResponse = await urlFetchCache.fetch(testUrl);
      expect(JSON.parse(anonResponse.data.toString()).request).toBe(2);
      expect(requestCount).toBe(2); // ✅ Separate cache entry

      // Verify different data
      expect(authResponse.data).not.toEqual(anonResponse.data);
    });

    it("should respect cache for same user making repeated requests", async () => {
      let requestCount = 0;
      const routePath = `/cached-data-${Date.now()}.csv`;
      testServer.route(routePath, (_req: IncomingMessage, res: ServerResponse) => {
        requestCount++;
        res.writeHead(200, {
          "Content-Type": "text/csv",
          "Cache-Control": "max-age=3600",
        });
        res.end(`id,value\n1,${requestCount}`);
      });

      const testUrl = `${serverUrl}${routePath}`;

      // UserA makes first request
      const response1 = await urlFetchCache.fetch(testUrl, { userId: userA.id.toString() });
      const data1 = response1.data.toString();
      expect(data1).toContain("1,1");
      expect(requestCount).toBe(1);

      // UserA makes second request - should hit cache
      const response2 = await urlFetchCache.fetch(testUrl, { userId: userA.id.toString() });
      const data2 = response2.data.toString();
      expect(data2).toContain("1,1"); // Same data
      expect(requestCount).toBe(1); // ✅ No new fetch (cached)

      // Verify same data returned
      expect(data1).toEqual(data2);
    });
  });

  describe("Fix Verified: User-Specific Cache Invalidation", () => {
    it("should invalidate cache for specific user without affecting others", async () => {
      let requestCount = 0;
      const routePath = `/shared-url-${Date.now()}.json`;
      testServer.route(routePath, (_req: IncomingMessage, res: ServerResponse) => {
        requestCount++;
        res.writeHead(200, { "Content-Type": "application/json" });
        res.end(JSON.stringify({ request: requestCount }));
      });

      const testUrl = `${serverUrl}${routePath}`;

      // Both users fetch and cache the data
      const userAResponse1 = await urlFetchCache.fetch(testUrl, { userId: userA.id.toString() });
      expect(JSON.parse(userAResponse1.data.toString()).request).toBe(1);

      const userBResponse1 = await urlFetchCache.fetch(testUrl, { userId: userB.id.toString() });
      expect(JSON.parse(userBResponse1.data.toString()).request).toBe(2);

      expect(requestCount).toBe(2);

      // Invalidate cache for UserA only
      await urlFetchCache.invalidateForUser(userA.id.toString());

      // UserA's next fetch should make a new request
      const userAResponse2 = await urlFetchCache.fetch(testUrl, { userId: userA.id.toString() });
      expect(JSON.parse(userAResponse2.data.toString()).request).toBe(3);
      expect(requestCount).toBe(3); // ✅ New fetch made

      // UserB's next fetch should still hit cache (not invalidated)
      const userBResponse2 = await urlFetchCache.fetch(testUrl, { userId: userB.id.toString() });
      expect(JSON.parse(userBResponse2.data.toString()).request).toBe(2); // Still cached!
      expect(requestCount).toBe(3); // ✅ No new fetch
    });
  });

  describe("Fix Verified: Cache Prevents Cross-User Data Leakage", () => {
    it("should not leak sensitive data between users", async () => {
      // Simulate endpoint that returns user-specific sensitive data
      const routePath = `/sensitive-data-${Date.now()}.json`;
      testServer.route(routePath, (_req: IncomingMessage, res: ServerResponse) => {
        // In reality, this would use auth headers to determine user
        // For test, we just return different data each time
        const data = {
          timestamp: Date.now(),
          secret: Math.random().toString(36).substring(7),
        };
        res.writeHead(200, { "Content-Type": "application/json" });
        res.end(JSON.stringify(data));
      });

      const testUrl = `${serverUrl}${routePath}`;

      // UserA fetches sensitive data
      const responseA = await urlFetchCache.fetch(testUrl, { userId: userA.id.toString() });
      const dataA = JSON.parse(responseA.data.toString());

      // Wait a bit to ensure different timestamp
      await new Promise((resolve) => setTimeout(resolve, 10));

      // UserB fetches the same URL
      const responseB = await urlFetchCache.fetch(testUrl, { userId: userB.id.toString() });
      const dataB = JSON.parse(responseB.data.toString());

      // ✅ PASS: Different data returned (not cached cross-user)
      expect(dataA.secret).not.toBe(dataB.secret);
      expect(dataA.timestamp).not.toBe(dataB.timestamp);
    });

    it("should isolate private import URLs between users", async () => {
      let userARequestCount = 0;
      let userBRequestCount = 0;

      const routePath = `/private-import-${Date.now()}.csv`;
      testServer.route(routePath, (_req: IncomingMessage, res: ServerResponse) => {
        // Simulate returning different data (as if auth was checked)
        // In reality, the server would check auth headers
        const isFirstCall = userARequestCount === 0 && userBRequestCount === 0;
        if (isFirstCall) {
          userARequestCount++;
        } else {
          userBRequestCount++;
        }

        const data = isFirstCall
          ? "UserA's confidential data\nrevenue,profit\n1000000,500000"
          : "UserB's confidential data\nrevenue,profit\n50000,25000";

        res.writeHead(200, { "Content-Type": "text/csv" });
        res.end(data);
      });

      const privateUrl = `${serverUrl}${routePath}`;

      // UserA imports their data
      const userAImport = await urlFetchCache.fetch(privateUrl, { userId: userA.id.toString() });
      const dataA = userAImport.data.toString();
      expect(dataA).toContain("UserA's confidential");

      // UserB tries to access the same URL
      const userBImport = await urlFetchCache.fetch(privateUrl, { userId: userB.id.toString() });
      const dataB = userBImport.data.toString();

      // ✅ PASS: UserB does NOT get UserA's cached data
      expect(dataB).not.toContain("UserA's confidential");
      expect(dataB).toContain("UserB's confidential");
    });
  });

  describe("Expected Cache Behavior", () => {
    it("should handle cache hits and misses correctly per user", async () => {
      const routePath = `/metrics-${Date.now()}.csv`;
      testServer.route(routePath, (_req: IncomingMessage, res: ServerResponse) => {
        res.writeHead(200, { "Content-Type": "text/csv" });
        res.end("id,value\n1,100");
      });

      const testUrl = `${serverUrl}${routePath}`;

      const initialStats = await urlFetchCache.getStats();
      const initialMisses = initialStats.misses;

      // UserA first fetch - should be a miss
      await urlFetchCache.fetch(testUrl, { userId: userA.id.toString() });
      const statsAfterA1 = await urlFetchCache.getStats();
      expect(statsAfterA1.misses).toBe(initialMisses + 1);

      // UserA second fetch - should be a hit
      await urlFetchCache.fetch(testUrl, { userId: userA.id.toString() });
      const statsAfterA2 = await urlFetchCache.getStats();
      expect(statsAfterA2.hits).toBeGreaterThan(initialStats.hits);

      // UserB first fetch - should be a miss (different cache key)
      await urlFetchCache.fetch(testUrl, { userId: userB.id.toString() });
      const statsAfterB1 = await urlFetchCache.getStats();
      expect(statsAfterB1.misses).toBe(initialMisses + 2); // Two misses total
    });
  });
});
