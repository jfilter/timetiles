// @vitest-environment node
/**
 * Security vulnerability tests for URL fetch cache data isolation.
 *
 * These tests demonstrate CRITICAL vulnerabilities in the URL fetch cache
 * where cache keys are based only on URL + HTTP method, with NO user isolation.
 *
 * **Expected Status**: ALL VULNERABILITY TESTS SHOULD FAIL
 *
 * This allows:
 * - User A's cached data to be served to User B
 * - Cross-user data contamination
 * - Privacy violations and data leakage
 *
 * Related Issue: security-access-control-remediation-plan.md #1.3
 *
 * @module
 */

import { afterAll, afterEach, beforeAll, beforeEach, describe, expect, it, vi } from "vitest";

import type { User } from "@/payload-types";
import { getUrlFetchCache } from "@/lib/services/cache/url-fetch-cache";
import { createIntegrationTestEnvironment } from "@/tests/setup/test-environment-builder";

const urlFetchCache = getUrlFetchCache();

// Mock fetch for controlled testing
const mockFetch = vi.fn();
global.fetch = mockFetch as any;

describe.sequential("URL Fetch Cache Isolation Vulnerabilities", () => {
  let payload: any;
  let cleanup: () => Promise<void>;

  let userA: User;
  let userB: User;

  beforeAll(async () => {
    const env = await createIntegrationTestEnvironment();
    payload = env.payload;
    cleanup = env.cleanup;

    // Create test users
    userA = await payload.create({
      collection: "users",
      data: {
        email: "user-a@cache-test.com",
        password: "password123",
        role: "user",
      },
    });

    userB = await payload.create({
      collection: "users",
      data: {
        email: "user-b@cache-test.com",
        password: "password123",
        role: "user",
      },
    });
  }, 60000);

  beforeEach(() => {
    // Clear mock and cache before each test
    mockFetch.mockClear();
  });

  afterEach(async () => {
    // Clear cache between tests
    await urlFetchCache.clear();
  });

  afterAll(async () => {
    await cleanup();
  });

  describe("Vulnerability: Cache Keys Don't Include User Context", () => {
    it("should FAIL: UserB receives UserA's cached data for same URL", async () => {
      const testUrl = "https://example.com/user-specific-data.csv";

      // UserA fetches data - mock returns userA-specific data
      mockFetch.mockResolvedValueOnce({
        ok: true,
        status: 200,
        statusText: "OK",
        headers: new Headers({
          "content-type": "text/csv",
          "cache-control": "max-age=3600",
        }),
        text: async () => "USER A PRIVATE DATA\nid,name\n1,Secret A",
      } as Response);

      const responseA = await urlFetchCache.fetch(testUrl);

      expect(responseA.data).toContain("USER A PRIVATE DATA");
      expect(mockFetch).toHaveBeenCalledTimes(1);

      // UserB fetches the SAME URL
      // In a secure system, this should either:
      // 1. Make a new fetch (different cache key for different user)
      // 2. Not use cache (user-specific data shouldn't be cached cross-user)

      mockFetch.mockResolvedValueOnce({
        ok: true,
        status: 200,
        statusText: "OK",
        headers: new Headers({
          "content-type": "text/csv",
        }),
        text: async () => "USER B PRIVATE DATA\nid,name\n2,Secret B",
      } as Response);

      const responseB = await urlFetchCache.fetch(testUrl);

      // âŒ FAILS: Should NOT contain UserA's data
      expect(responseB.data).not.toContain("USER A PRIVATE DATA");
      expect(responseB.data).toContain("USER B PRIVATE DATA");

      // âŒ FAILS: Should have made a second fetch for UserB
      expect(mockFetch).toHaveBeenCalledTimes(2);

      if (responseB.data.toString().includes("USER A PRIVATE DATA")) {
        console.warn("ğŸš¨ CRITICAL: Cache served UserA's data to UserB!");
        console.warn(`   URL: ${testUrl}`);
        console.warn(`   UserB received: ${responseB.data.toString().substring(0, 50)}...`);
        console.warn(`   Actual fetch calls: ${mockFetch.mock.calls.length} (expected 2)`);
      }
    });

    it("should FAIL: Cache statistics show cross-user hits", async () => {
      const testUrl = "https://example.com/shared-url-different-auth.json";

      // UserA fetches
      mockFetch.mockResolvedValueOnce({
        ok: true,
        status: 200,
        statusText: "OK",
        headers: new Headers({
          "content-type": "application/json",
        }),
        json: async () => ({ user: "A", secret: "UserA's secret token" }),
        text: async () => JSON.stringify({ user: "A", secret: "UserA's secret token" }),
      } as Response);

      await urlFetchCache.fetch(testUrl);

      const statsAfterA = await urlFetchCache.getStats();
      const missesAfterA = statsAfterA.misses;

      // UserB fetches same URL
      mockFetch.mockResolvedValueOnce({
        ok: true,
        status: 200,
        statusText: "OK",
        headers: new Headers({
          "content-type": "application/json",
        }),
        json: async () => ({ user: "B", secret: "UserB's secret token" }),
        text: async () => JSON.stringify({ user: "B", secret: "UserB's secret token" }),
      } as Response);

      await urlFetchCache.fetch(testUrl);

      const statsAfterB = await urlFetchCache.getStats();

      // âŒ FAILS: Should be 2 misses (one per user), not 1 miss + 1 hit
      const expectedMisses = missesAfterA + 1;
      expect(statsAfterB.misses).toBe(expectedMisses);

      if (statsAfterB.hits > 0) {
        console.warn("ğŸš¨ SECURITY ISSUE: Cache hit across different users!");
        console.warn(`   Misses: ${statsAfterB.misses}, Hits: ${statsAfterB.hits}`);
        console.warn(`   This indicates UserB used UserA's cached data`);
      }
    });
  });

  describe("Vulnerability: Sensitive Data Cached Without User Context", () => {
    it("should FAIL: Admin data cached and served to regular user", async () => {
      const adminUrl = "https://api.example.com/admin/sensitive-data.json";

      // Admin user (hypothetical) fetches sensitive data
      mockFetch.mockResolvedValueOnce({
        ok: true,
        status: 200,
        statusText: "OK",
        headers: new Headers({
          "content-type": "application/json",
        }),
        text: async () =>
          JSON.stringify({
            users: [
              { email: "user1@example.com", role: "admin", apiKey: "secret123" },
              { email: "user2@example.com", role: "user", apiKey: "secret456" },
            ],
          }),
      } as Response);

      const adminResponse = await urlFetchCache.fetch(adminUrl);
      expect(adminResponse.data).toContain("secret123");

      // Regular user fetches the same URL (shouldn't have cached admin data)
      const userResponse = await urlFetchCache.fetch(adminUrl);

      // âŒ FAILS: Should not serve cached admin data to regular user
      expect(userResponse.data).not.toContain("secret123");

      if (userResponse.data.includes("secret123")) {
        console.warn("ğŸš¨ CRITICAL: Admin sensitive data served to regular user!");
        console.warn(`   Exposed API keys and admin information`);
      }
    });

    it("should FAIL: Private import URLs cached cross-user", async () => {
      const privateImportUrl = "https://private-server.com/user-imports/data.csv";

      // UserA's private import
      mockFetch.mockResolvedValueOnce({
        ok: true,
        status: 200,
        statusText: "OK",
        headers: new Headers({
          "content-type": "text/csv",
        }),
        text: async () => "UserA's confidential business data\nrevenue,profit\n1000000,500000",
      } as Response);

      const userAImport = await urlFetchCache.fetch(privateImportUrl);
      expect(userAImport.data).toContain("UserA's confidential");

      // UserB somehow gets the same URL (perhaps guessed or leaked)
      const userBImport = await urlFetchCache.fetch(privateImportUrl);

      // âŒ FAILS: Should NOT serve UserA's data to UserB
      expect(userBImport.data).not.toContain("UserA's confidential");
      expect(mockFetch).toHaveBeenCalledTimes(2);

      if (userBImport.data.includes("UserA's confidential")) {
        console.warn("ğŸš¨ CRITICAL: Private import data leaked between users!");
        console.warn(`   UserB accessed UserA's business data`);
      }
    });
  });

  describe("Vulnerability: No User-Specific Cache Invalidation", () => {
    it("should FAIL: Clearing cache for one user should not affect another user", async () => {
      const sharedUrl = "https://example.com/potentially-shared.json";

      // Both users fetch the same URL
      mockFetch.mockResolvedValue({
        ok: true,
        status: 200,
        statusText: "OK",
        headers: new Headers(),
        text: async () => "cached data",
      } as Response);

      await urlFetchCache.fetch(sharedUrl); // UserA
      await urlFetchCache.fetch(sharedUrl); // UserB (gets cached data)

      // In a user-isolated cache system, we should be able to:
      // 1. Invalidate UserA's cache without affecting UserB
      // 2. Have user-specific cache keys

      // Currently, there's NO way to invalidate for a specific user
      // This test documents the missing functionality

      expect(true).toBe(true); // Placeholder - no API for user-specific invalidation

      console.warn("ğŸš¨ SECURITY GAP: No user-specific cache invalidation");
      console.warn(`   Cannot clear cache for one user without affecting others`);
      console.warn(`   Missing: urlFetchCache.invalidateForUser(userId)`);
    });
  });

  describe("Vulnerability: Anonymous vs Authenticated Cache Not Separated", () => {
    it("should FAIL: Anonymous fetch should not use authenticated user's cache", async () => {
      const publicApiUrl = "https://api.example.com/public/data.json";

      // Authenticated user fetches with auth headers
      mockFetch.mockResolvedValueOnce({
        ok: true,
        status: 200,
        statusText: "OK",
        headers: new Headers(),
        text: async () =>
          JSON.stringify({
            data: "response for authenticated user",
            premium: true,
          }),
      } as Response);

      const authResponse = await urlFetchCache.fetch(publicApiUrl, {
        headers: { Authorization: "Bearer token123" },
      });

      expect(authResponse.data).toContain("authenticated user");

      // Anonymous fetch (no auth)
      mockFetch.mockResolvedValueOnce({
        ok: true,
        status: 200,
        statusText: "OK",
        headers: new Headers(),
        text: async () =>
          JSON.stringify({
            data: "response for anonymous user",
            premium: false,
          }),
      } as Response);

      const anonResponse = await urlFetchCache.fetch(publicApiUrl);

      // âŒ FAILS: Should get different response for anonymous
      expect(anonResponse.data).not.toContain("authenticated user");
      expect(anonResponse.data).toContain("anonymous user");
      expect(mockFetch).toHaveBeenCalledTimes(2);

      if (anonResponse.data.includes("authenticated user")) {
        console.warn("ğŸš¨ CRITICAL: Authenticated cache served to anonymous user!");
      }
    });
  });

  describe("Expected Behavior After Fix", () => {
    it("should make separate fetches for different users (user-isolated cache)", async () => {
      const url = "https://example.com/data.csv";

      // With user-isolated cache, each user should get their own cache entry
      // Even if it's the same URL
      mockFetch.mockResolvedValue({
        ok: true,
        status: 200,
        statusText: "OK",
        headers: new Headers(),
        text: async () => "data",
      } as Response);

      // If userId were passed to cache:
      // await urlFetchCache.fetch(url, { userId: userA.id });
      // await urlFetchCache.fetch(url, { userId: userB.id });

      // Should result in 2 fetches (one per user)
      // expect(mockFetch).toHaveBeenCalledTimes(2);

      console.warn("ğŸ“ TODO: Add userId parameter to urlFetchCache.fetch()");
      console.warn("ğŸ“ TODO: Include userId in cache key generation");
    });

    it("should support user-specific cache invalidation", async () => {
      // After fix, should be able to:
      // await urlFetchCache.invalidateForUser(userA.id);
      // Without affecting userB's cache

      console.warn("ğŸ“ TODO: Implement urlFetchCache.invalidateForUser(userId)");
    });
  });
});
