/**
 * API route for triggering on-demand schema inference for a dataset.
 *
 * This endpoint allows editors and admins to generate a schema for datasets
 * that weren't created through the import pipeline (e.g., seeding, direct
 * event creation via API).
 *
 * Access control:
 * - Editors and admins can infer schema for any dataset
 * - Schema is generated by sampling existing events in the dataset
 *
 * @module
 * @category API
 */
import { NextResponse } from "next/server";
import { getPayload } from "payload";

import { logError, logger } from "@/lib/logger";
import { type AuthenticatedRequest, withAuth } from "@/lib/middleware/auth";
import { SchemaInferenceService } from "@/lib/services/schema-inference-service";
import { badRequest, forbidden, internalError, notFound } from "@/lib/utils/api-response";
import config from "@/payload.config";

export const POST = withAuth(
  async (request: AuthenticatedRequest, context: { params: Promise<{ id: string }> }): Promise<NextResponse> => {
    try {
      const payload = await getPayload({ config });
      const { id } = await context.params;
      const datasetId = parseInt(id, 10);

      if (isNaN(datasetId)) {
        return badRequest("Invalid dataset ID");
      }

      // Check user permissions - only editors and admins can infer schema
      if (!request.user || (request.user.role !== "editor" && request.user.role !== "admin")) {
        return forbidden("Only editors and admins can trigger schema inference");
      }

      // Verify dataset exists
      const dataset = await payload
        .findByID({
          collection: "datasets",
          id: datasetId,
          overrideAccess: true,
        })
        .catch(() => null);

      if (!dataset) {
        return notFound("Dataset not found");
      }

      // Parse options from request body (optional)
      let options: { sampleSize?: number; batchSize?: number; forceRegenerate?: boolean } = {};
      try {
        const body = await request.json().catch(() => ({}));
        options = {
          sampleSize: typeof body.sampleSize === "number" ? body.sampleSize : undefined,
          batchSize: typeof body.batchSize === "number" ? body.batchSize : undefined,
          forceRegenerate: typeof body.forceRegenerate === "boolean" ? body.forceRegenerate : undefined,
        };
      } catch {
        // No body or invalid JSON - use defaults
      }

      logger.info("Schema inference requested", {
        datasetId,
        userId: request.user.id,
        options,
      });

      // Perform schema inference
      const result = await SchemaInferenceService.inferSchemaFromEvents(payload, datasetId, options);

      logger.info("Schema inference completed", {
        datasetId,
        userId: request.user.id,
        generated: result.generated,
        eventsSampled: result.eventsSampled,
      });

      return NextResponse.json({
        success: true,
        generated: result.generated,
        message: result.message,
        eventsSampled: result.eventsSampled,
        schema: result.schema
          ? {
              id: result.schema.id,
              versionNumber: result.schema.versionNumber,
              createdAt: result.schema.createdAt,
              eventCountAtCreation: result.schema.eventCountAtCreation,
            }
          : null,
      });
    } catch (error) {
      const { id } = await context.params;
      logError(error, "Failed to infer schema for dataset", {
        datasetId: id,
        userId: request.user?.id,
      });

      return internalError("Failed to infer schema for dataset");
    }
  }
);
