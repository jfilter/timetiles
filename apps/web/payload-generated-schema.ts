/* tslint:disable */
/* eslint-disable */
/**
 * This file was automatically generated by Payload.
 * DO NOT MODIFY IT BY HAND. Instead, modify your source Payload config,
 * and re-run `payload generate:db-schema` to regenerate this file.
 */

import type {} from "@payloadcms/db-postgres";
import {
  pgSchema,
  index,
  uniqueIndex,
  foreignKey,
  serial,
  varchar,
  jsonb,
  timestamp,
  integer,
  boolean,
  numeric,
} from "@payloadcms/db-postgres/drizzle/pg-core";
import { sql, relations } from "@payloadcms/db-postgres/drizzle";
export const db_schema = pgSchema("payload");
export const enum_catalogs_status = db_schema.enum("enum_catalogs_status", [
  "active",
  "archived",
]);
export const enum_datasets_status = db_schema.enum("enum_datasets_status", [
  "draft",
  "active",
  "archived",
]);
export const enum_imports_job_history_job_type = db_schema.enum(
  "enum_imports_job_history_job_type",
  ["file-parsing", "batch-processing", "geocoding-batch", "event-creation"],
);
export const enum_imports_job_history_status = db_schema.enum(
  "enum_imports_job_history_status",
  ["queued", "running", "completed", "failed"],
);
export const enum_imports_status = db_schema.enum("enum_imports_status", [
  "pending",
  "processing",
  "completed",
  "failed",
]);
export const enum_imports_processing_stage = db_schema.enum(
  "enum_imports_processing_stage",
  [
    "file-parsing",
    "row-processing",
    "geocoding",
    "event-creation",
    "completed",
  ],
);
export const enum_imports_coordinate_detection_detection_method =
  db_schema.enum("enum_imports_coordinate_detection_detection_method", [
    "pattern",
    "heuristic",
    "manual",
    "none",
  ]);
export const coord_fmt = db_schema.enum("coord_fmt", [
  "decimal",
  "dms",
  "combined_comma",
  "combined_space",
  "geojson",
]);
export const enum_events_coordinate_source_type = db_schema.enum(
  "enum_events_coordinate_source_type",
  ["import", "geocoded", "manual", "none"],
);
export const enum_events_coordinate_source_validation_status = db_schema.enum(
  "enum_events_coordinate_source_validation_status",
  ["valid", "out_of_range", "suspicious_zero", "swapped", "invalid"],
);
export const enum_events_geocoding_info_provider = db_schema.enum(
  "enum_events_geocoding_info_provider",
  ["google", "nominatim", "manual"],
);
export const enum_users_role = db_schema.enum("enum_users_role", [
  "user",
  "admin",
  "analyst",
]);
export const enum_geocoding_providers_tags = db_schema.enum(
  "enum_geocoding_providers_tags",
  [
    "production",
    "development",
    "testing",
    "backup",
    "primary",
    "secondary",
    "region-us",
    "region-eu",
    "region-asia",
    "region-global",
    "high-volume",
    "low-volume",
    "free-tier",
    "paid-tier",
  ],
);
export const enum_geocoding_providers_type = db_schema.enum(
  "enum_geocoding_providers_type",
  ["google", "nominatim", "opencage"],
);
export const enum_payload_jobs_log_task_slug = db_schema.enum(
  "enum_payload_jobs_log_task_slug",
  [
    "inline",
    "file-parsing",
    "batch-processing",
    "event-creation",
    "geocoding-batch",
  ],
);
export const enum_payload_jobs_log_state = db_schema.enum(
  "enum_payload_jobs_log_state",
  ["failed", "succeeded"],
);
export const enum_payload_jobs_task_slug = db_schema.enum(
  "enum_payload_jobs_task_slug",
  [
    "inline",
    "file-parsing",
    "batch-processing",
    "event-creation",
    "geocoding-batch",
  ],
);

export const catalogs = db_schema.table(
  "catalogs",
  {
    id: serial("id").primaryKey(),
    name: varchar("name").notNull(),
    description: jsonb("description"),
    slug: varchar("slug"),
    status: enum_catalogs_status("status").default("active"),
    updatedAt: timestamp("updated_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp("created_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    catalogs_slug_idx: uniqueIndex("catalogs_slug_idx").on(columns.slug),
    catalogs_updated_at_idx: index("catalogs_updated_at_idx").on(
      columns.updatedAt,
    ),
    catalogs_created_at_idx: index("catalogs_created_at_idx").on(
      columns.createdAt,
    ),
  }),
);

export const datasets = db_schema.table(
  "datasets",
  {
    id: serial("id").primaryKey(),
    name: varchar("name").notNull(),
    description: jsonb("description"),
    slug: varchar("slug"),
    catalog: integer("catalog_id")
      .notNull()
      .references(() => catalogs.id, {
        onDelete: "set null",
      }),
    language: varchar("language").notNull(),
    status: enum_datasets_status("status").default("active"),
    isPublic: boolean("is_public").default(false),
    schema: jsonb("schema").notNull(),
    metadata: jsonb("metadata"),
    updatedAt: timestamp("updated_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp("created_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    datasets_slug_idx: uniqueIndex("datasets_slug_idx").on(columns.slug),
    datasets_catalog_idx: index("datasets_catalog_idx").on(columns.catalog),
    datasets_updated_at_idx: index("datasets_updated_at_idx").on(
      columns.updatedAt,
    ),
    datasets_created_at_idx: index("datasets_created_at_idx").on(
      columns.createdAt,
    ),
  }),
);

export const imports_job_history = db_schema.table(
  "imports_job_history",
  {
    _order: integer("_order").notNull(),
    _parentID: integer("_parent_id").notNull(),
    id: varchar("id").primaryKey(),
    jobId: varchar("job_id").notNull(),
    jobType: enum_imports_job_history_job_type("job_type").notNull(),
    status: enum_imports_job_history_status("status").notNull(),
    startedAt: timestamp("started_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }),
    completedAt: timestamp("completed_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }),
    error: varchar("error"),
    result: jsonb("result"),
  },
  (columns) => ({
    _orderIdx: index("imports_job_history_order_idx").on(columns._order),
    _parentIDIdx: index("imports_job_history_parent_id_idx").on(
      columns._parentID,
    ),
    _parentIDFk: foreignKey({
      columns: [columns["_parentID"]],
      foreignColumns: [imports.id],
      name: "imports_job_history_parent_id_fk",
    }).onDelete("cascade"),
  }),
);

export const imports = db_schema.table(
  "imports",
  {
    id: serial("id").primaryKey(),
    fileName: varchar("file_name").notNull(),
    originalName: varchar("original_name"),
    catalog: integer("catalog_id")
      .notNull()
      .references(() => catalogs.id, {
        onDelete: "set null",
      }),
    fileSize: numeric("file_size"),
    mimeType: varchar("mime_type"),
    user: integer("user_id").references(() => users.id, {
      onDelete: "set null",
    }),
    sessionId: varchar("session_id"),
    status: enum_imports_status("status").default("pending"),
    processingStage:
      enum_imports_processing_stage("processing_stage").default("file-parsing"),
    importedAt: timestamp("imported_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }),
    completedAt: timestamp("completed_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }),
    rowCount: numeric("row_count").notNull(),
    errorCount: numeric("error_count").default("0"),
    errorLog: varchar("error_log"),
    progress_totalRows: numeric("progress_total_rows").default("0"),
    progress_processedRows: numeric("progress_processed_rows").default("0"),
    progress_geocodedRows: numeric("progress_geocoded_rows").default("0"),
    progress_createdEvents: numeric("progress_created_events").default("0"),
    progress_percentage: numeric("progress_percentage").default("0"),
    batchInfo_batchSize: numeric("batch_info_batch_size").default("100"),
    batchInfo_currentBatch: numeric("batch_info_current_batch").default("0"),
    batchInfo_totalBatches: numeric("batch_info_total_batches").default("0"),
    geocodingStats_totalAddresses: numeric(
      "geocoding_stats_total_addresses",
    ).default("0"),
    geocodingStats_successfulGeocodes: numeric(
      "geocoding_stats_successful_geocodes",
    ).default("0"),
    geocodingStats_failedGeocodes: numeric(
      "geocoding_stats_failed_geocodes",
    ).default("0"),
    geocodingStats_cachedResults: numeric(
      "geocoding_stats_cached_results",
    ).default("0"),
    geocodingStats_googleApiCalls: numeric(
      "geocoding_stats_google_api_calls",
    ).default("0"),
    geocodingStats_nominatimApiCalls: numeric(
      "geocoding_stats_nominatim_api_calls",
    ).default("0"),
    geocodingStats_preExistingCoordinates: numeric(
      "geocoding_stats_pre_existing_coordinates",
    ).default("0"),
    geocodingStats_skippedGeocoding: numeric(
      "geocoding_stats_skipped_geocoding",
    ).default("0"),
    rateLimitInfo: jsonb("rate_limit_info"),
    currentJobId: varchar("current_job_id"),
    coordinateDetection_detected: boolean(
      "coordinate_detection_detected",
    ).default(false),
    coordinateDetection_detectionMethod:
      enum_imports_coordinate_detection_detection_method(
        "coordinate_detection_detection_method",
      ),
    coordinateDetection_columnMapping_latitudeColumn: varchar(
      "coordinate_detection_column_mapping_latitude_column",
    ),
    coordinateDetection_columnMapping_longitudeColumn: varchar(
      "coordinate_detection_column_mapping_longitude_column",
    ),
    coordinateDetection_columnMapping_combinedColumn: varchar(
      "coordinate_detection_column_mapping_combined_column",
    ),
    coordinateDetection_columnMapping_coordinateFormat: coord_fmt(
      "coordinate_detection_column_mapping_coordinate_format",
    ),
    coordinateDetection_detectionConfidence: numeric(
      "coordinate_detection_detection_confidence",
    ),
    coordinateDetection_sampleValidation_validSamples: numeric(
      "coordinate_detection_sample_validation_valid_samples",
    ).default("0"),
    coordinateDetection_sampleValidation_invalidSamples: numeric(
      "coordinate_detection_sample_validation_invalid_samples",
    ).default("0"),
    coordinateDetection_sampleValidation_swappedCoordinates: boolean(
      "coordinate_detection_sample_validation_swapped_coordinates",
    ).default(false),
    metadata: jsonb("metadata"),
    updatedAt: timestamp("updated_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp("created_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    imports_catalog_idx: index("imports_catalog_idx").on(columns.catalog),
    imports_user_idx: index("imports_user_idx").on(columns.user),
    imports_updated_at_idx: index("imports_updated_at_idx").on(
      columns.updatedAt,
    ),
    imports_created_at_idx: index("imports_created_at_idx").on(
      columns.createdAt,
    ),
  }),
);

export const events = db_schema.table(
  "events",
  {
    id: serial("id").primaryKey(),
    dataset: integer("dataset_id")
      .notNull()
      .references(() => datasets.id, {
        onDelete: "set null",
      }),
    import: integer("import_id").references(() => imports.id, {
      onDelete: "set null",
    }),
    data: jsonb("data").notNull(),
    location_latitude: numeric("location_latitude"),
    location_longitude: numeric("location_longitude"),
    coordinateSource_type: enum_events_coordinate_source_type(
      "coordinate_source_type",
    ).default("none"),
    coordinateSource_importColumns_latitudeColumn: varchar(
      "coordinate_source_import_columns_latitude_column",
    ),
    coordinateSource_importColumns_longitudeColumn: varchar(
      "coordinate_source_import_columns_longitude_column",
    ),
    coordinateSource_importColumns_combinedColumn: varchar(
      "coordinate_source_import_columns_combined_column",
    ),
    coordinateSource_importColumns_format: varchar(
      "coordinate_source_import_columns_format",
    ),
    coordinateSource_confidence: numeric("coordinate_source_confidence"),
    coordinateSource_validationStatus:
      enum_events_coordinate_source_validation_status(
        "coordinate_source_validation_status",
      ),
    eventTimestamp: timestamp("event_timestamp", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }),
    isValid: boolean("is_valid").default(true),
    validationErrors: jsonb("validation_errors"),
    geocodingInfo_originalAddress: varchar("geocoding_info_original_address"),
    geocodingInfo_provider: enum_events_geocoding_info_provider(
      "geocoding_info_provider",
    ),
    geocodingInfo_confidence: numeric("geocoding_info_confidence"),
    geocodingInfo_normalizedAddress: varchar(
      "geocoding_info_normalized_address",
    ),
    slug: varchar("slug"),
    updatedAt: timestamp("updated_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp("created_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    events_dataset_idx: index("events_dataset_idx").on(columns.dataset),
    events_import_idx: index("events_import_idx").on(columns.import),
    events_slug_idx: uniqueIndex("events_slug_idx").on(columns.slug),
    events_updated_at_idx: index("events_updated_at_idx").on(columns.updatedAt),
    events_created_at_idx: index("events_created_at_idx").on(columns.createdAt),
    dataset_eventTimestamp_idx: index("dataset_eventTimestamp_idx").on(
      columns.dataset,
      columns.eventTimestamp,
    ),
    eventTimestamp_idx: index("eventTimestamp_idx").on(columns.eventTimestamp),
  }),
);

export const users_sessions = db_schema.table(
  "users_sessions",
  {
    _order: integer("_order").notNull(),
    _parentID: integer("_parent_id").notNull(),
    id: varchar("id").primaryKey(),
    createdAt: timestamp("created_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }),
    expiresAt: timestamp("expires_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }).notNull(),
  },
  (columns) => ({
    _orderIdx: index("users_sessions_order_idx").on(columns._order),
    _parentIDIdx: index("users_sessions_parent_id_idx").on(columns._parentID),
    _parentIDFk: foreignKey({
      columns: [columns["_parentID"]],
      foreignColumns: [users.id],
      name: "users_sessions_parent_id_fk",
    }).onDelete("cascade"),
  }),
);

export const users = db_schema.table(
  "users",
  {
    id: serial("id").primaryKey(),
    firstName: varchar("first_name"),
    lastName: varchar("last_name"),
    role: enum_users_role("role").default("user"),
    isActive: boolean("is_active").default(true),
    lastLoginAt: timestamp("last_login_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }),
    updatedAt: timestamp("updated_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp("created_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    email: varchar("email").notNull(),
    resetPasswordToken: varchar("reset_password_token"),
    resetPasswordExpiration: timestamp("reset_password_expiration", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }),
    salt: varchar("salt"),
    hash: varchar("hash"),
    loginAttempts: numeric("login_attempts").default("0"),
    lockUntil: timestamp("lock_until", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }),
  },
  (columns) => ({
    users_updated_at_idx: index("users_updated_at_idx").on(columns.updatedAt),
    users_created_at_idx: index("users_created_at_idx").on(columns.createdAt),
    users_email_idx: uniqueIndex("users_email_idx").on(columns.email),
  }),
);

export const media = db_schema.table(
  "media",
  {
    id: serial("id").primaryKey(),
    alt: varchar("alt"),
    updatedAt: timestamp("updated_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp("created_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    url: varchar("url"),
    thumbnailURL: varchar("thumbnail_u_r_l"),
    filename: varchar("filename"),
    mimeType: varchar("mime_type"),
    filesize: numeric("filesize"),
    width: numeric("width"),
    height: numeric("height"),
    focalX: numeric("focal_x"),
    focalY: numeric("focal_y"),
    sizes_thumbnail_url: varchar("sizes_thumbnail_url"),
    sizes_thumbnail_width: numeric("sizes_thumbnail_width"),
    sizes_thumbnail_height: numeric("sizes_thumbnail_height"),
    sizes_thumbnail_mimeType: varchar("sizes_thumbnail_mime_type"),
    sizes_thumbnail_filesize: numeric("sizes_thumbnail_filesize"),
    sizes_thumbnail_filename: varchar("sizes_thumbnail_filename"),
    sizes_card_url: varchar("sizes_card_url"),
    sizes_card_width: numeric("sizes_card_width"),
    sizes_card_height: numeric("sizes_card_height"),
    sizes_card_mimeType: varchar("sizes_card_mime_type"),
    sizes_card_filesize: numeric("sizes_card_filesize"),
    sizes_card_filename: varchar("sizes_card_filename"),
    sizes_tablet_url: varchar("sizes_tablet_url"),
    sizes_tablet_width: numeric("sizes_tablet_width"),
    sizes_tablet_height: numeric("sizes_tablet_height"),
    sizes_tablet_mimeType: varchar("sizes_tablet_mime_type"),
    sizes_tablet_filesize: numeric("sizes_tablet_filesize"),
    sizes_tablet_filename: varchar("sizes_tablet_filename"),
  },
  (columns) => ({
    media_updated_at_idx: index("media_updated_at_idx").on(columns.updatedAt),
    media_created_at_idx: index("media_created_at_idx").on(columns.createdAt),
    media_filename_idx: uniqueIndex("media_filename_idx").on(columns.filename),
    media_sizes_thumbnail_sizes_thumbnail_filename_idx: index(
      "media_sizes_thumbnail_sizes_thumbnail_filename_idx",
    ).on(columns.sizes_thumbnail_filename),
    media_sizes_card_sizes_card_filename_idx: index(
      "media_sizes_card_sizes_card_filename_idx",
    ).on(columns.sizes_card_filename),
    media_sizes_tablet_sizes_tablet_filename_idx: index(
      "media_sizes_tablet_sizes_tablet_filename_idx",
    ).on(columns.sizes_tablet_filename),
  }),
);

export const location_cache = db_schema.table(
  "location_cache",
  {
    id: serial("id").primaryKey(),
    originalAddress: varchar("original_address").notNull(),
    normalizedAddress: varchar("normalized_address").notNull(),
    latitude: numeric("latitude").notNull(),
    longitude: numeric("longitude").notNull(),
    provider: varchar("provider").notNull(),
    confidence: numeric("confidence"),
    hitCount: numeric("hit_count").default("1"),
    lastUsed: timestamp("last_used", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }),
    components_streetNumber: varchar("components_street_number"),
    components_streetName: varchar("components_street_name"),
    components_city: varchar("components_city"),
    components_region: varchar("components_region"),
    components_postalCode: varchar("components_postal_code"),
    components_country: varchar("components_country"),
    metadata: jsonb("metadata"),
    updatedAt: timestamp("updated_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp("created_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    location_cache_original_address_idx: uniqueIndex(
      "location_cache_original_address_idx",
    ).on(columns.originalAddress),
    location_cache_normalized_address_idx: index(
      "location_cache_normalized_address_idx",
    ).on(columns.normalizedAddress),
    location_cache_updated_at_idx: index("location_cache_updated_at_idx").on(
      columns.updatedAt,
    ),
    location_cache_created_at_idx: index("location_cache_created_at_idx").on(
      columns.createdAt,
    ),
  }),
);

export const geocoding_providers_tags = db_schema.table(
  "geocoding_providers_tags",
  {
    order: integer("order").notNull(),
    parent: integer("parent_id").notNull(),
    value: enum_geocoding_providers_tags("value"),
    id: serial("id").primaryKey(),
  },
  (columns) => ({
    orderIdx: index("geocoding_providers_tags_order_idx").on(columns.order),
    parentIdx: index("geocoding_providers_tags_parent_idx").on(columns.parent),
    parentFk: foreignKey({
      columns: [columns["parent"]],
      foreignColumns: [geocoding_providers.id],
      name: "geocoding_providers_tags_parent_fk",
    }).onDelete("cascade"),
  }),
);

export const geocoding_providers = db_schema.table(
  "geocoding_providers",
  {
    id: serial("id").primaryKey(),
    name: varchar("name").notNull(),
    type: enum_geocoding_providers_type("type").notNull(),
    enabled: boolean("enabled").default(true),
    priority: numeric("priority").notNull().default("1"),
    rateLimit: numeric("rate_limit").default("10"),
    config_google_apiKey: varchar("config_google_api_key"),
    config_google_region: varchar("config_google_region"),
    config_google_language: varchar("config_google_language").default("en"),
    config_nominatim_baseUrl: varchar("config_nominatim_base_url").default(
      "https://nominatim.openstreetmap.org",
    ),
    config_nominatim_userAgent: varchar("config_nominatim_user_agent").default(
      "TimeTiles-App/1.0",
    ),
    config_nominatim_email: varchar("config_nominatim_email"),
    config_nominatim_countrycodes: varchar("config_nominatim_countrycodes"),
    config_nominatim_addressdetails: boolean(
      "config_nominatim_addressdetails",
    ).default(true),
    config_nominatim_extratags: boolean("config_nominatim_extratags").default(
      false,
    ),
    config_opencage_apiKey: varchar("config_GEOCODING_OPENCAGE_API_KEY"),
    config_opencage_language: varchar("config_opencage_language").default("en"),
    config_opencage_countrycode: varchar("config_opencage_countrycode"),
    config_opencage_bounds_enabled: boolean(
      "config_opencage_bounds_enabled",
    ).default(false),
    config_opencage_bounds_southwest_lat: numeric(
      "config_opencage_bounds_southwest_lat",
    ),
    config_opencage_bounds_southwest_lng: numeric(
      "config_opencage_bounds_southwest_lng",
    ),
    config_opencage_bounds_northeast_lat: numeric(
      "config_opencage_bounds_northeast_lat",
    ),
    config_opencage_bounds_northeast_lng: numeric(
      "config_opencage_bounds_northeast_lng",
    ),
    config_opencage_annotations: boolean("config_opencage_annotations").default(
      true,
    ),
    config_opencage_abbrv: boolean("config_opencage_abbrv").default(false),
    statistics_totalRequests: numeric("statistics_total_requests").default("0"),
    statistics_successfulRequests: numeric(
      "statistics_successful_requests",
    ).default("0"),
    statistics_failedRequests: numeric("statistics_failed_requests").default(
      "0",
    ),
    statistics_lastUsed: timestamp("statistics_last_used", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }),
    statistics_averageResponseTime: numeric("statistics_average_response_time"),
    notes: varchar("notes"),
    updatedAt: timestamp("updated_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp("created_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    geocoding_providers_name_idx: uniqueIndex(
      "geocoding_providers_name_idx",
    ).on(columns.name),
    geocoding_providers_updated_at_idx: index(
      "geocoding_providers_updated_at_idx",
    ).on(columns.updatedAt),
    geocoding_providers_created_at_idx: index(
      "geocoding_providers_created_at_idx",
    ).on(columns.createdAt),
  }),
);

export const pages = db_schema.table(
  "pages",
  {
    id: serial("id").primaryKey(),
    title: varchar("title").notNull(),
    slug: varchar("slug").notNull(),
    content: jsonb("content"),
    updatedAt: timestamp("updated_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp("created_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    pages_slug_idx: uniqueIndex("pages_slug_idx").on(columns.slug),
    pages_updated_at_idx: index("pages_updated_at_idx").on(columns.updatedAt),
    pages_created_at_idx: index("pages_created_at_idx").on(columns.createdAt),
  }),
);

export const payload_jobs_log = db_schema.table(
  "payload_jobs_log",
  {
    _order: integer("_order").notNull(),
    _parentID: integer("_parent_id").notNull(),
    id: varchar("id").primaryKey(),
    executedAt: timestamp("executed_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }).notNull(),
    completedAt: timestamp("completed_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }).notNull(),
    taskSlug: enum_payload_jobs_log_task_slug("task_slug").notNull(),
    taskID: varchar("task_i_d").notNull(),
    input: jsonb("input"),
    output: jsonb("output"),
    state: enum_payload_jobs_log_state("state").notNull(),
    error: jsonb("error"),
  },
  (columns) => ({
    _orderIdx: index("payload_jobs_log_order_idx").on(columns._order),
    _parentIDIdx: index("payload_jobs_log_parent_id_idx").on(columns._parentID),
    _parentIDFk: foreignKey({
      columns: [columns["_parentID"]],
      foreignColumns: [payload_jobs.id],
      name: "payload_jobs_log_parent_id_fk",
    }).onDelete("cascade"),
  }),
);

export const payload_jobs = db_schema.table(
  "payload_jobs",
  {
    id: serial("id").primaryKey(),
    input: jsonb("input"),
    completedAt: timestamp("completed_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }),
    totalTried: numeric("total_tried").default("0"),
    hasError: boolean("has_error").default(false),
    error: jsonb("error"),
    taskSlug: enum_payload_jobs_task_slug("task_slug"),
    queue: varchar("queue").default("default"),
    waitUntil: timestamp("wait_until", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }),
    processing: boolean("processing").default(false),
    updatedAt: timestamp("updated_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp("created_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    payload_jobs_completed_at_idx: index("payload_jobs_completed_at_idx").on(
      columns.completedAt,
    ),
    payload_jobs_total_tried_idx: index("payload_jobs_total_tried_idx").on(
      columns.totalTried,
    ),
    payload_jobs_has_error_idx: index("payload_jobs_has_error_idx").on(
      columns.hasError,
    ),
    payload_jobs_task_slug_idx: index("payload_jobs_task_slug_idx").on(
      columns.taskSlug,
    ),
    payload_jobs_queue_idx: index("payload_jobs_queue_idx").on(columns.queue),
    payload_jobs_wait_until_idx: index("payload_jobs_wait_until_idx").on(
      columns.waitUntil,
    ),
    payload_jobs_processing_idx: index("payload_jobs_processing_idx").on(
      columns.processing,
    ),
    payload_jobs_updated_at_idx: index("payload_jobs_updated_at_idx").on(
      columns.updatedAt,
    ),
    payload_jobs_created_at_idx: index("payload_jobs_created_at_idx").on(
      columns.createdAt,
    ),
  }),
);

export const payload_locked_documents = db_schema.table(
  "payload_locked_documents",
  {
    id: serial("id").primaryKey(),
    globalSlug: varchar("global_slug"),
    updatedAt: timestamp("updated_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp("created_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    payload_locked_documents_global_slug_idx: index(
      "payload_locked_documents_global_slug_idx",
    ).on(columns.globalSlug),
    payload_locked_documents_updated_at_idx: index(
      "payload_locked_documents_updated_at_idx",
    ).on(columns.updatedAt),
    payload_locked_documents_created_at_idx: index(
      "payload_locked_documents_created_at_idx",
    ).on(columns.createdAt),
  }),
);

export const payload_locked_documents_rels = db_schema.table(
  "payload_locked_documents_rels",
  {
    id: serial("id").primaryKey(),
    order: integer("order"),
    parent: integer("parent_id").notNull(),
    path: varchar("path").notNull(),
    catalogsID: integer("catalogs_id"),
    datasetsID: integer("datasets_id"),
    importsID: integer("imports_id"),
    eventsID: integer("events_id"),
    usersID: integer("users_id"),
    mediaID: integer("media_id"),
    "location-cacheID": integer("location_cache_id"),
    "geocoding-providersID": integer("geocoding_providers_id"),
    pagesID: integer("pages_id"),
    "payload-jobsID": integer("payload_jobs_id"),
  },
  (columns) => ({
    order: index("payload_locked_documents_rels_order_idx").on(columns.order),
    parentIdx: index("payload_locked_documents_rels_parent_idx").on(
      columns.parent,
    ),
    pathIdx: index("payload_locked_documents_rels_path_idx").on(columns.path),
    payload_locked_documents_rels_catalogs_id_idx: index(
      "payload_locked_documents_rels_catalogs_id_idx",
    ).on(columns.catalogsID),
    payload_locked_documents_rels_datasets_id_idx: index(
      "payload_locked_documents_rels_datasets_id_idx",
    ).on(columns.datasetsID),
    payload_locked_documents_rels_imports_id_idx: index(
      "payload_locked_documents_rels_imports_id_idx",
    ).on(columns.importsID),
    payload_locked_documents_rels_events_id_idx: index(
      "payload_locked_documents_rels_events_id_idx",
    ).on(columns.eventsID),
    payload_locked_documents_rels_users_id_idx: index(
      "payload_locked_documents_rels_users_id_idx",
    ).on(columns.usersID),
    payload_locked_documents_rels_media_id_idx: index(
      "payload_locked_documents_rels_media_id_idx",
    ).on(columns.mediaID),
    payload_locked_documents_rels_location_cache_id_idx: index(
      "payload_locked_documents_rels_location_cache_id_idx",
    ).on(columns["location-cacheID"]),
    payload_locked_documents_rels_geocoding_providers_id_idx: index(
      "payload_locked_documents_rels_geocoding_providers_id_idx",
    ).on(columns["geocoding-providersID"]),
    payload_locked_documents_rels_pages_id_idx: index(
      "payload_locked_documents_rels_pages_id_idx",
    ).on(columns.pagesID),
    payload_locked_documents_rels_payload_jobs_id_idx: index(
      "payload_locked_documents_rels_payload_jobs_id_idx",
    ).on(columns["payload-jobsID"]),
    parentFk: foreignKey({
      columns: [columns["parent"]],
      foreignColumns: [payload_locked_documents.id],
      name: "payload_locked_documents_rels_parent_fk",
    }).onDelete("cascade"),
    catalogsIdFk: foreignKey({
      columns: [columns["catalogsID"]],
      foreignColumns: [catalogs.id],
      name: "payload_locked_documents_rels_catalogs_fk",
    }).onDelete("cascade"),
    datasetsIdFk: foreignKey({
      columns: [columns["datasetsID"]],
      foreignColumns: [datasets.id],
      name: "payload_locked_documents_rels_datasets_fk",
    }).onDelete("cascade"),
    importsIdFk: foreignKey({
      columns: [columns["importsID"]],
      foreignColumns: [imports.id],
      name: "payload_locked_documents_rels_imports_fk",
    }).onDelete("cascade"),
    eventsIdFk: foreignKey({
      columns: [columns["eventsID"]],
      foreignColumns: [events.id],
      name: "payload_locked_documents_rels_events_fk",
    }).onDelete("cascade"),
    usersIdFk: foreignKey({
      columns: [columns["usersID"]],
      foreignColumns: [users.id],
      name: "payload_locked_documents_rels_users_fk",
    }).onDelete("cascade"),
    mediaIdFk: foreignKey({
      columns: [columns["mediaID"]],
      foreignColumns: [media.id],
      name: "payload_locked_documents_rels_media_fk",
    }).onDelete("cascade"),
    "location-cacheIdFk": foreignKey({
      columns: [columns["location-cacheID"]],
      foreignColumns: [location_cache.id],
      name: "payload_locked_documents_rels_location_cache_fk",
    }).onDelete("cascade"),
    "geocoding-providersIdFk": foreignKey({
      columns: [columns["geocoding-providersID"]],
      foreignColumns: [geocoding_providers.id],
      name: "payload_locked_documents_rels_geocoding_providers_fk",
    }).onDelete("cascade"),
    pagesIdFk: foreignKey({
      columns: [columns["pagesID"]],
      foreignColumns: [pages.id],
      name: "payload_locked_documents_rels_pages_fk",
    }).onDelete("cascade"),
    "payload-jobsIdFk": foreignKey({
      columns: [columns["payload-jobsID"]],
      foreignColumns: [payload_jobs.id],
      name: "payload_locked_documents_rels_payload_jobs_fk",
    }).onDelete("cascade"),
  }),
);

export const payload_preferences = db_schema.table(
  "payload_preferences",
  {
    id: serial("id").primaryKey(),
    key: varchar("key"),
    value: jsonb("value"),
    updatedAt: timestamp("updated_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp("created_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    payload_preferences_key_idx: index("payload_preferences_key_idx").on(
      columns.key,
    ),
    payload_preferences_updated_at_idx: index(
      "payload_preferences_updated_at_idx",
    ).on(columns.updatedAt),
    payload_preferences_created_at_idx: index(
      "payload_preferences_created_at_idx",
    ).on(columns.createdAt),
  }),
);

export const payload_preferences_rels = db_schema.table(
  "payload_preferences_rels",
  {
    id: serial("id").primaryKey(),
    order: integer("order"),
    parent: integer("parent_id").notNull(),
    path: varchar("path").notNull(),
    usersID: integer("users_id"),
  },
  (columns) => ({
    order: index("payload_preferences_rels_order_idx").on(columns.order),
    parentIdx: index("payload_preferences_rels_parent_idx").on(columns.parent),
    pathIdx: index("payload_preferences_rels_path_idx").on(columns.path),
    payload_preferences_rels_users_id_idx: index(
      "payload_preferences_rels_users_id_idx",
    ).on(columns.usersID),
    parentFk: foreignKey({
      columns: [columns["parent"]],
      foreignColumns: [payload_preferences.id],
      name: "payload_preferences_rels_parent_fk",
    }).onDelete("cascade"),
    usersIdFk: foreignKey({
      columns: [columns["usersID"]],
      foreignColumns: [users.id],
      name: "payload_preferences_rels_users_fk",
    }).onDelete("cascade"),
  }),
);

export const payload_migrations = db_schema.table(
  "payload_migrations",
  {
    id: serial("id").primaryKey(),
    name: varchar("name"),
    batch: numeric("batch"),
    updatedAt: timestamp("updated_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp("created_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    payload_migrations_updated_at_idx: index(
      "payload_migrations_updated_at_idx",
    ).on(columns.updatedAt),
    payload_migrations_created_at_idx: index(
      "payload_migrations_created_at_idx",
    ).on(columns.createdAt),
  }),
);

export const main_menu_nav_items = db_schema.table(
  "main_menu_nav_items",
  {
    _order: integer("_order").notNull(),
    _parentID: integer("_parent_id").notNull(),
    id: varchar("id").primaryKey(),
    label: varchar("label").notNull(),
    url: varchar("url").notNull(),
  },
  (columns) => ({
    _orderIdx: index("main_menu_nav_items_order_idx").on(columns._order),
    _parentIDIdx: index("main_menu_nav_items_parent_id_idx").on(
      columns._parentID,
    ),
    _parentIDFk: foreignKey({
      columns: [columns["_parentID"]],
      foreignColumns: [main_menu.id],
      name: "main_menu_nav_items_parent_id_fk",
    }).onDelete("cascade"),
  }),
);

export const main_menu = db_schema.table("main_menu", {
  id: serial("id").primaryKey(),
  updatedAt: timestamp("updated_at", {
    mode: "string",
    withTimezone: true,
    precision: 3,
  }),
  createdAt: timestamp("created_at", {
    mode: "string",
    withTimezone: true,
    precision: 3,
  }),
});

export const relations_catalogs = relations(catalogs, () => ({}));
export const relations_datasets = relations(datasets, ({ one }) => ({
  catalog: one(catalogs, {
    fields: [datasets.catalog],
    references: [catalogs.id],
    relationName: "catalog",
  }),
}));
export const relations_imports_job_history = relations(
  imports_job_history,
  ({ one }) => ({
    _parentID: one(imports, {
      fields: [imports_job_history._parentID],
      references: [imports.id],
      relationName: "jobHistory",
    }),
  }),
);
export const relations_imports = relations(imports, ({ one, many }) => ({
  catalog: one(catalogs, {
    fields: [imports.catalog],
    references: [catalogs.id],
    relationName: "catalog",
  }),
  user: one(users, {
    fields: [imports.user],
    references: [users.id],
    relationName: "user",
  }),
  jobHistory: many(imports_job_history, {
    relationName: "jobHistory",
  }),
}));
export const relations_events = relations(events, ({ one }) => ({
  dataset: one(datasets, {
    fields: [events.dataset],
    references: [datasets.id],
    relationName: "dataset",
  }),
  import: one(imports, {
    fields: [events.import],
    references: [imports.id],
    relationName: "import",
  }),
}));
export const relations_users_sessions = relations(
  users_sessions,
  ({ one }) => ({
    _parentID: one(users, {
      fields: [users_sessions._parentID],
      references: [users.id],
      relationName: "sessions",
    }),
  }),
);
export const relations_users = relations(users, ({ many }) => ({
  sessions: many(users_sessions, {
    relationName: "sessions",
  }),
}));
export const relations_media = relations(media, () => ({}));
export const relations_location_cache = relations(location_cache, () => ({}));
export const relations_geocoding_providers_tags = relations(
  geocoding_providers_tags,
  ({ one }) => ({
    parent: one(geocoding_providers, {
      fields: [geocoding_providers_tags.parent],
      references: [geocoding_providers.id],
      relationName: "tags",
    }),
  }),
);
export const relations_geocoding_providers = relations(
  geocoding_providers,
  ({ many }) => ({
    tags: many(geocoding_providers_tags, {
      relationName: "tags",
    }),
  }),
);
export const relations_pages = relations(pages, () => ({}));
export const relations_payload_jobs_log = relations(
  payload_jobs_log,
  ({ one }) => ({
    _parentID: one(payload_jobs, {
      fields: [payload_jobs_log._parentID],
      references: [payload_jobs.id],
      relationName: "log",
    }),
  }),
);
export const relations_payload_jobs = relations(payload_jobs, ({ many }) => ({
  log: many(payload_jobs_log, {
    relationName: "log",
  }),
}));
export const relations_payload_locked_documents_rels = relations(
  payload_locked_documents_rels,
  ({ one }) => ({
    parent: one(payload_locked_documents, {
      fields: [payload_locked_documents_rels.parent],
      references: [payload_locked_documents.id],
      relationName: "_rels",
    }),
    catalogsID: one(catalogs, {
      fields: [payload_locked_documents_rels.catalogsID],
      references: [catalogs.id],
      relationName: "catalogs",
    }),
    datasetsID: one(datasets, {
      fields: [payload_locked_documents_rels.datasetsID],
      references: [datasets.id],
      relationName: "datasets",
    }),
    importsID: one(imports, {
      fields: [payload_locked_documents_rels.importsID],
      references: [imports.id],
      relationName: "imports",
    }),
    eventsID: one(events, {
      fields: [payload_locked_documents_rels.eventsID],
      references: [events.id],
      relationName: "events",
    }),
    usersID: one(users, {
      fields: [payload_locked_documents_rels.usersID],
      references: [users.id],
      relationName: "users",
    }),
    mediaID: one(media, {
      fields: [payload_locked_documents_rels.mediaID],
      references: [media.id],
      relationName: "media",
    }),
    "location-cacheID": one(location_cache, {
      fields: [payload_locked_documents_rels["location-cacheID"]],
      references: [location_cache.id],
      relationName: "location-cache",
    }),
    "geocoding-providersID": one(geocoding_providers, {
      fields: [payload_locked_documents_rels["geocoding-providersID"]],
      references: [geocoding_providers.id],
      relationName: "geocoding-providers",
    }),
    pagesID: one(pages, {
      fields: [payload_locked_documents_rels.pagesID],
      references: [pages.id],
      relationName: "pages",
    }),
    "payload-jobsID": one(payload_jobs, {
      fields: [payload_locked_documents_rels["payload-jobsID"]],
      references: [payload_jobs.id],
      relationName: "payload-jobs",
    }),
  }),
);
export const relations_payload_locked_documents = relations(
  payload_locked_documents,
  ({ many }) => ({
    _rels: many(payload_locked_documents_rels, {
      relationName: "_rels",
    }),
  }),
);
export const relations_payload_preferences_rels = relations(
  payload_preferences_rels,
  ({ one }) => ({
    parent: one(payload_preferences, {
      fields: [payload_preferences_rels.parent],
      references: [payload_preferences.id],
      relationName: "_rels",
    }),
    usersID: one(users, {
      fields: [payload_preferences_rels.usersID],
      references: [users.id],
      relationName: "users",
    }),
  }),
);
export const relations_payload_preferences = relations(
  payload_preferences,
  ({ many }) => ({
    _rels: many(payload_preferences_rels, {
      relationName: "_rels",
    }),
  }),
);
export const relations_payload_migrations = relations(
  payload_migrations,
  () => ({}),
);
export const relations_main_menu_nav_items = relations(
  main_menu_nav_items,
  ({ one }) => ({
    _parentID: one(main_menu, {
      fields: [main_menu_nav_items._parentID],
      references: [main_menu.id],
      relationName: "navItems",
    }),
  }),
);
export const relations_main_menu = relations(main_menu, ({ many }) => ({
  navItems: many(main_menu_nav_items, {
    relationName: "navItems",
  }),
}));

type DatabaseSchema = {
  db_schema: typeof db_schema;
  enum_catalogs_status: typeof enum_catalogs_status;
  enum_datasets_status: typeof enum_datasets_status;
  enum_imports_job_history_job_type: typeof enum_imports_job_history_job_type;
  enum_imports_job_history_status: typeof enum_imports_job_history_status;
  enum_imports_status: typeof enum_imports_status;
  enum_imports_processing_stage: typeof enum_imports_processing_stage;
  enum_imports_coordinate_detection_detection_method: typeof enum_imports_coordinate_detection_detection_method;
  coord_fmt: typeof coord_fmt;
  enum_events_coordinate_source_type: typeof enum_events_coordinate_source_type;
  enum_events_coordinate_source_validation_status: typeof enum_events_coordinate_source_validation_status;
  enum_events_geocoding_info_provider: typeof enum_events_geocoding_info_provider;
  enum_users_role: typeof enum_users_role;
  enum_geocoding_providers_tags: typeof enum_geocoding_providers_tags;
  enum_geocoding_providers_type: typeof enum_geocoding_providers_type;
  enum_payload_jobs_log_task_slug: typeof enum_payload_jobs_log_task_slug;
  enum_payload_jobs_log_state: typeof enum_payload_jobs_log_state;
  enum_payload_jobs_task_slug: typeof enum_payload_jobs_task_slug;
  catalogs: typeof catalogs;
  datasets: typeof datasets;
  imports_job_history: typeof imports_job_history;
  imports: typeof imports;
  events: typeof events;
  users_sessions: typeof users_sessions;
  users: typeof users;
  media: typeof media;
  location_cache: typeof location_cache;
  geocoding_providers_tags: typeof geocoding_providers_tags;
  geocoding_providers: typeof geocoding_providers;
  pages: typeof pages;
  payload_jobs_log: typeof payload_jobs_log;
  payload_jobs: typeof payload_jobs;
  payload_locked_documents: typeof payload_locked_documents;
  payload_locked_documents_rels: typeof payload_locked_documents_rels;
  payload_preferences: typeof payload_preferences;
  payload_preferences_rels: typeof payload_preferences_rels;
  payload_migrations: typeof payload_migrations;
  main_menu_nav_items: typeof main_menu_nav_items;
  main_menu: typeof main_menu;
  relations_catalogs: typeof relations_catalogs;
  relations_datasets: typeof relations_datasets;
  relations_imports_job_history: typeof relations_imports_job_history;
  relations_imports: typeof relations_imports;
  relations_events: typeof relations_events;
  relations_users_sessions: typeof relations_users_sessions;
  relations_users: typeof relations_users;
  relations_media: typeof relations_media;
  relations_location_cache: typeof relations_location_cache;
  relations_geocoding_providers_tags: typeof relations_geocoding_providers_tags;
  relations_geocoding_providers: typeof relations_geocoding_providers;
  relations_pages: typeof relations_pages;
  relations_payload_jobs_log: typeof relations_payload_jobs_log;
  relations_payload_jobs: typeof relations_payload_jobs;
  relations_payload_locked_documents_rels: typeof relations_payload_locked_documents_rels;
  relations_payload_locked_documents: typeof relations_payload_locked_documents;
  relations_payload_preferences_rels: typeof relations_payload_preferences_rels;
  relations_payload_preferences: typeof relations_payload_preferences;
  relations_payload_migrations: typeof relations_payload_migrations;
  relations_main_menu_nav_items: typeof relations_main_menu_nav_items;
  relations_main_menu: typeof relations_main_menu;
};

declare module "@payloadcms/db-postgres" {
  export interface GeneratedDatabaseSchema {
    schema: DatabaseSchema;
  }
}
