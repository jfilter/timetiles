# Rate Limiting

The rate limiting system protects API endpoints from abuse by limiting the frequency of requests within short time windows. It works alongside the [quota system](/developer-guide/quotas) to provide comprehensive resource protection.

## Rate Limiting vs Quotas

While both systems control resource usage, they serve different purposes:

| Aspect | Rate Limiting | Quotas |
|--------|--------------|--------|
| **Purpose** | Prevent burst attacks/abuse | Manage long-term resource allocation |
| **Storage** | In-memory (ephemeral) | Database (persistent) |
| **Scope** | Per IP address or identifier | Per user ID |
| **Time Windows** | Seconds to hours | Hours to lifetime |
| **Reset** | Sliding windows | Fixed time (midnight UTC) |
| **Use Case** | DDoS protection, spam prevention | Fair resource distribution |

### Example: File Upload Protection

When a user uploads a file, both systems check:

```typescript
// 1. Rate Limiting (fast fail, prevents abuse)
const rateLimitCheck = rateLimitService.checkTrustLevelRateLimit(
  clientIp,
  user,
  "FILE_UPLOAD"
);
// Checks: 1 per 5 seconds, 5 per hour, 20 per day

// 2. Quotas (accurate, prevents resource exhaustion)
const quotaCheck = await quotaService.checkQuota(
  user,
  QUOTA_TYPES.FILE_UPLOADS_PER_DAY
);
// Checks: Total uploads today vs limit (e.g., 10/day)
```

**Rate limiting runs first** (in-memory, instant) to quickly reject abusive patterns, then **quotas verify** (database query) against long-term resource limits.

## Multi-Window Rate Limiting

The rate limit service supports multiple time windows to catch different abuse patterns:

### Window Types

**Burst Protection** (seconds to minutes)
- Prevents rapid-fire requests
- Example: 1 request per 5 seconds

**Hourly Limits**
- Prevents sustained abuse
- Example: 5 requests per hour

**Daily Limits**
- Prevents long-term abuse patterns
- Example: 20 requests per day

### Configuration Example

```typescript
export const RATE_LIMITS = {
  FILE_UPLOAD: {
    windows: [
      { limit: 1, windowMs: 5 * 1000, name: "burst" },      // 1 per 5 sec
      { limit: 5, windowMs: 60 * 60 * 1000, name: "hourly" },  // 5 per hour
      { limit: 20, windowMs: 24 * 60 * 60 * 1000, name: "daily" }, // 20 per day
    ],
  },
  API_GENERAL: {
    windows: [
      { limit: 5, windowMs: 1000, name: "burst" },         // 5 per second
      { limit: 50, windowMs: 60 * 60 * 1000, name: "hourly" }, // 50 per hour
    ],
  },
};
```

**How it works**: All windows must pass. If any window fails, the request is denied immediately.

## Trust-Level-Based Rate Limits

Rate limits automatically adjust based on user trust level (see [Quotas - Trust Levels](/developer-guide/quotas#trust-levels)):

### File Upload Rate Limits by Trust Level

| Trust Level | Burst | Hourly | Daily |
|-------------|-------|--------|-------|
| **Untrusted (0)** | 1 per min | 1/hour | 1/day |
| **Basic (1)** | 1 per 10s | 3/hour | 3/day |
| **Regular (2)** | 1 per 5s | 5/hour | 20/day |
| **Trusted (3)** | 2 per 5s | 20/hour | 50/day |
| **Power User (4)** | 5 per 5s | 100/hour | 200/day |
| **Unlimited (5)** | 10 per sec | 1000/hour | No daily limit |

### API General Rate Limits by Trust Level

| Trust Level | Burst | Hourly |
|-------------|-------|--------|
| **Untrusted (0)** | 1 per sec | 10/hour |
| **Basic (1)** | 2 per sec | 30/hour |
| **Regular (2)** | 5 per sec | 50/hour |
| **Trusted (3)** | 10 per sec | 200/hour |
| **Power User (4)** | 20 per sec | 1000/hour |
| **Unlimited (5)** | 100 per sec | 10000/hour |

Higher trust levels automatically receive more generous rate limits, allowing trusted users to work efficiently without hitting limits.

## Implementation

### Basic Rate Limit Check

```typescript
import { getRateLimitService } from "@/lib/services/rate-limit-service";

const rateLimitService = getRateLimitService(payload);

// Simple single-window check
const result = rateLimitService.checkRateLimit(
  "user-identifier",
  10,    // limit: 10 requests
  60000  // window: 60 seconds
);

if (!result.allowed) {
  return NextResponse.json(
    { error: "Rate limit exceeded" },
    { status: 429 }
  );
}
```

### Multi-Window Rate Limit Check

```typescript
const rateLimitService = getRateLimitService(payload);

const result = rateLimitService.checkMultiWindowRateLimit(
  "webhook:token123",
  [
    { limit: 1, windowMs: 10 * 1000, name: "burst" },
    { limit: 5, windowMs: 60 * 60 * 1000, name: "hourly" },
  ]
);

if (!result.allowed) {
  return NextResponse.json(
    {
      error: "Rate limit exceeded",
      window: result.failedWindow,  // "burst" or "hourly"
      resetTime: result.resetTime,
    },
    { status: 429 }
  );
}
```

### Trust-Level-Aware Rate Limiting

```typescript
import {
  getRateLimitService,
  getClientIdentifier
} from "@/lib/services/rate-limit-service";

const rateLimitService = getRateLimitService(payload);
const clientIp = getClientIdentifier(request);

// Automatically uses trust-level-based limits
const result = rateLimitService.checkTrustLevelRateLimit(
  clientIp,
  user,           // User object (or null for unauthenticated)
  "FILE_UPLOAD"   // Endpoint type
);

if (!result.allowed) {
  throw new Error(
    `Rate limit exceeded. Limited by ${result.failedWindow} window.`
  );
}
```

## HTTP Headers and Responses

### Rate Limit Headers

When rate limits are checked, responses include informational headers:

```
X-RateLimit-Limit: 10
X-RateLimit-Remaining: 7
X-RateLimit-Reset: 2025-10-06T15:30:00.000Z
X-RateLimit-Blocked: false
```

### Rate Limit Exceeded Response

When rate limits are exceeded, the API returns a 429 status:

```json
{
  "success": false,
  "error": "Rate limit exceeded",
  "message": "Too many requests. Please wait 10 seconds between webhook calls.",
  "limitType": "burst",
  "retryAfter": "2025-10-06T15:30:00.000Z"
}
```

The `Retry-After` header (in seconds) is also included:

```
HTTP/1.1 429 Too Many Requests
Retry-After: 10
```

## Real-World Examples

### Webhook Rate Limiting

The webhook trigger endpoint uses dual-window rate limiting to prevent race conditions and abuse:

```typescript
// apps/web/app/api/webhooks/trigger/[token]/route.ts
const rateLimitCheck = rateLimitService.checkConfiguredRateLimit(
  `webhook:${token}`,
  RATE_LIMITS.WEBHOOK_TRIGGER
);

if (!rateLimitCheck.allowed) {
  const message = rateLimitCheck.failedWindow === "burst"
    ? "Too many requests. Please wait 10 seconds between webhook calls."
    : "Hourly rate limit exceeded. Maximum 5 requests per hour.";

  return NextResponse.json(
    {
      success: false,
      error: "Rate limit exceeded",
      message,
      limitType: rateLimitCheck.failedWindow,
      retryAfter: new Date(rateLimitCheck.resetTime).toISOString(),
    },
    {
      status: 429,
      headers: {
        "Retry-After": Math.ceil(
          (rateLimitCheck.resetTime - Date.now()) / 1000
        ).toString(),
      },
    }
  );
}
```

**Configuration**:
```typescript
WEBHOOK_TRIGGER: {
  windows: [
    { limit: 1, windowMs: 10 * 1000, name: "burst" },  // 1 per 10 seconds
    { limit: 5, windowMs: 60 * 60 * 1000, name: "hourly" }, // 5 per hour
  ],
}
```

This prevents:
- **Race conditions**: 10-second window ensures previous import finishes
- **Abuse**: Hourly limit caps total automated triggers

### File Upload Rate Limiting

File uploads use trust-level-aware rate limiting in Payload hooks:

```typescript
// apps/web/lib/collections/import-files.ts
beforeChange: [
  ({ data, req }) => {
    const rateLimitService = getRateLimitService(req.payload);
    const clientId = getClientIdentifier(req);

    // Trust level automatically determines limits
    const result = rateLimitService.checkTrustLevelRateLimit(
      clientId,
      req.user,
      "FILE_UPLOAD"
    );

    if (!result.allowed) {
      throw new Error(
        `Too many import requests. Please try again later. ` +
        `(Limited by ${result.failedWindow} window)`
      );
    }

    return { ...data, rateLimitInfo: { clientId, timestamp: new Date() } };
  }
]
```

This protects against:
- **Burst uploads**: Prevents rapid file spam
- **Hourly abuse**: Limits sustained upload attacks
- **Daily flooding**: Caps total daily upload attempts

## Service Architecture

### RateLimitService Class

Located in `apps/web/lib/services/rate-limit-service.ts`

**Key Methods**:
- `checkRateLimit(identifier, limit, windowMs)` - Single window check
- `checkMultiWindowRateLimit(identifier, windows)` - Multiple windows
- `checkConfiguredRateLimit(identifier, config)` - Using config object
- `checkTrustLevelRateLimit(identifier, user, endpointType)` - Trust-level-aware
- `getRateLimitStatus(identifier)` - Get current status without incrementing
- `resetRateLimit(identifier)` - Clear rate limit for identifier
- `blockIdentifier(identifier, durationMs)` - Manually block identifier
- `getStatistics()` - Get service statistics

### Storage and Cleanup

**In-Memory Storage**:
- Uses JavaScript Map for fast lookups
- No database overhead
- Data doesn't persist across restarts

**Automatic Cleanup**:
- Expired entries removed every 5 minutes
- Configurable cleanup interval
- Prevents memory leaks

**Test Isolation**:
- Creates new instance per test
- No shared state between tests
- Cleanup interval disabled in tests

## Best Practices

### 1. Check Rate Limits Early
```typescript
// ✅ Check before expensive operations
const rateCheck = rateLimitService.checkRateLimit(clientId, limit, window);
if (!rateCheck.allowed) return errorResponse();

// Then do expensive work
await processLargeFile();
```

### 2. Use Appropriate Windows
```typescript
// ✅ Multiple windows for comprehensive protection
windows: [
  { limit: 1, windowMs: 5000, name: "burst" },     // Prevent spam
  { limit: 10, windowMs: 3600000, name: "hourly" }, // Prevent abuse
]

// ❌ Single window may miss abuse patterns
windows: [
  { limit: 100, windowMs: 3600000, name: "hourly" }, // Allows 100 rapid requests
]
```

### 3. Provide Clear Error Messages
```typescript
// ✅ Tell users what limit they hit and when it resets
if (!result.allowed) {
  return {
    error: `Rate limit exceeded: ${result.failedWindow}`,
    resetTime: result.resetTime,
    remaining: 0,
  };
}

// ❌ Generic error messages frustrate users
if (!result.allowed) {
  return { error: "Too many requests" };
}
```

### 4. Use Trust-Level Checks When Possible
```typescript
// ✅ Automatically adjusts limits based on trust
rateLimitService.checkTrustLevelRateLimit(clientId, user, "FILE_UPLOAD");

// ❌ Manual checks don't scale with trust levels
rateLimitService.checkRateLimit(clientId, 5, 60000);
```

### 5. Combine with Quotas
```typescript
// ✅ Rate limit first (fast), then quota check (accurate)
const rateCheck = rateLimitService.checkTrustLevelRateLimit(...);
if (!rateCheck.allowed) throw new Error("Rate limit exceeded");

const quotaCheck = await quotaService.checkQuota(...);
if (!quotaCheck.allowed) throw new QuotaExceededError(...);

// ❌ Only checking one leaves gaps
const quotaCheck = await quotaService.checkQuota(...);
// Missing burst protection!
```

## When to Use Rate Limiting

### Use Rate Limiting For:
- ✅ Public API endpoints
- ✅ Webhook endpoints (prevent race conditions)
- ✅ Authentication endpoints (prevent brute force)
- ✅ File upload endpoints (prevent spam)
- ✅ Any endpoint vulnerable to abuse

### Don't Use Rate Limiting For:
- ❌ Internal service calls
- ❌ Admin-only operations (use quotas instead)
- ❌ Read-heavy endpoints with caching
- ❌ Idempotent operations with low cost

## Monitoring and Debugging

### Get Service Statistics

```typescript
const stats = rateLimitService.getStatistics();
console.log(stats);
// {
//   totalEntries: 1523,
//   blockedEntries: 7,
//   activeEntries: 1516
// }
```

### Check Status Without Incrementing

```typescript
const status = rateLimitService.getRateLimitStatus("user-123");
if (status) {
  console.log(`Requests: ${status.count}`);
  console.log(`Resets: ${new Date(status.resetTime)}`);
  console.log(`Blocked: ${status.blocked}`);
}
```

### Reset Rate Limit Manually

```typescript
// For testing or manual intervention
rateLimitService.resetRateLimit("user-123");
```

### Block Identifier Manually

```typescript
// Block for 24 hours
rateLimitService.blockIdentifier(
  "abusive-ip",
  24 * 60 * 60 * 1000
);
```

## Configuration Reference

Rate limit configurations are defined in `lib/constants/quota-constants.ts` under `RATE_LIMITS_BY_TRUST_LEVEL`.

### Adding New Endpoint Types

To add rate limiting for a new endpoint:

1. **Define the configuration**:
```typescript
// lib/constants/quota-constants.ts
export const RATE_LIMITS_BY_TRUST_LEVEL = {
  [TRUST_LEVELS.REGULAR]: {
    // ... existing configs
    MY_NEW_ENDPOINT: {
      windows: [
        { limit: 5, windowMs: 1000, name: "burst" },
        { limit: 100, windowMs: 60 * 60 * 1000, name: "hourly" },
      ],
    },
  },
  // ... repeat for all trust levels
};
```

2. **Apply in your endpoint**:
```typescript
const result = rateLimitService.checkTrustLevelRateLimit(
  clientId,
  user,
  "MY_NEW_ENDPOINT"
);
```

## Relationship to Quotas

Rate limiting and [quotas](/developer-guide/quotas) work together but serve different purposes:

**Both systems check on every operation**:
1. **Rate Limit** checks first (in-memory, instant)
   - Rejects if too many requests in time window
   - Returns 429 with Retry-After header

2. **Quota** checks second (database query)
   - Rejects if daily/lifetime limit exceeded
   - Returns 429 with reset time and current usage

**Example Flow**:
```
Request → Rate Limit Check → Quota Check → Process Request
            ↓ Fail              ↓ Fail         ↓ Success
           429 (burst)         429 (daily)    200 OK
```

For more information on quotas, see the [Quotas documentation](/developer-guide/quotas).
