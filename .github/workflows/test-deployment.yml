name: Test Production Deployment

on:
  push:
    branches: [main]
    paths:
      - 'deployment/**'
      - 'deploy.sh'
      - 'docker compose.dev.yml'
      - '.dockerignore'
      - '.github/workflows/test-deployment.yml'

  pull_request:
    branches: [main]
    paths:
      - 'deployment/**'
      - 'deploy.sh'
      - 'docker compose.dev.yml'
      - '.dockerignore'
      - '.github/workflows/test-deployment.yml'
      
  workflow_dispatch:
    inputs:
      debug:
        description: 'Enable debug logging'
        required: false
        default: 'false'

jobs:
  test-production-deployment:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          lfs: true

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Make deploy script executable
        run: chmod +x deploy.sh deployment/deploy.sh

      - name: Run setup
        run: |
          ./deploy.sh setup

          # Verify files were created
          if [ ! -f deployment/.env.production ]; then
            echo "Setup failed - .env.production not created!"
            exit 1
          fi

          # Set test values
          sed -i 's/CHANGE_ME_STRONG_PASSWORD/test_password_123/g' deployment/.env.production
          sed -i 's/your-domain.com/localhost/g' deployment/.env.production
          sed -i 's/admin@${DOMAIN_NAME}/test@localhost/g' deployment/.env.production

          # Show config (without secrets)
          echo "=== Test Configuration ==="
          grep -E "^[^#]" deployment/.env.production | grep -v PASSWORD | grep -v SECRET

      - name: Prepare nginx configuration
        run: |
          echo "Preparing nginx configuration for testing..."

          # Create temporary nginx config directory
          mkdir -p deployment/nginx-test/sites-enabled

          # Copy nginx configs to temp directory
          cp deployment/nginx/nginx.conf deployment/nginx-test/nginx.conf
          cp -r deployment/nginx/sites-enabled/* deployment/nginx-test/sites-enabled/

          # Substitute DOMAIN_NAME in ALL temp configs
          find deployment/nginx-test/sites-enabled -type f -name "*.conf" -exec sed -i 's/${DOMAIN_NAME}/localhost/g' {} \;

          echo "Nginx config prepared with substitutions applied"

          # Create docker-compose override for testing with absolute paths
          cat > deployment/docker-compose.test.yml << EOF
          services:
            nginx:
              volumes:
                - $(pwd)/deployment/nginx-test/nginx.conf:/etc/nginx/nginx.conf:ro
                - $(pwd)/deployment/nginx-test/sites-enabled:/etc/nginx/sites-enabled:ro
                - $(pwd)/deployment/ssl:/etc/letsencrypt:ro
                - certbot-webroot:/var/www/certbot:ro

          volumes:
            certbot-webroot:
          EOF

          echo "Docker compose override created with absolute paths"
          cat deployment/docker-compose.test.yml

      - name: Generate self-signed SSL certificate
        run: |
          echo "Generating self-signed certificate for testing..."

          # Create directory for certificates
          mkdir -p deployment/ssl/live/localhost

          # Generate self-signed certificate
          openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
            -keyout deployment/ssl/live/localhost/privkey.pem \
            -out deployment/ssl/live/localhost/fullchain.pem \
            -subj "/C=US/ST=Test/L=Test/O=Test/CN=localhost"

          echo "SSL certificates generated"

      - name: Build Docker image
        run: |
          ./deploy.sh build

          # Check image size
          IMAGE_SIZE=$(docker images --format "{{.Size}}" timetiles-web:latest)
          echo "Docker image size: $IMAGE_SIZE"

      - name: Start services
        run: |
          ./deploy.sh up

      - name: Wait for services to be healthy
        run: |
          echo "Waiting for services to be ready..."
          sleep 10

          ./deploy.sh status

          echo "Waiting for web app via nginx (testing production-like setup)..."
          echo "Note: Migrations run automatically via prodMigrations on startup"
          max_attempts=30
          attempt=0
          while [ $attempt -lt $max_attempts ]; do
            if curl -f --max-time 5 http://localhost:80/api/health 2>/dev/null; then
              echo "Health check passed via nginx!"
              break
            fi
            echo "Waiting for application... (attempt $((attempt+1))/$max_attempts)"
            sleep 2
            attempt=$((attempt+1))
          done

          if [ $attempt -eq $max_attempts ]; then
            echo "Health check failed after $max_attempts attempts"
            echo "Checking nginx and web container logs:"
            cd deployment
            docker compose -f docker-compose.prod.yml -f docker-compose.test.yml --env-file .env.production logs --tail=50
            exit 1
          fi

      - name: Test nginx proxy (HTTP and HTTPS)
        run: |
          echo "Testing nginx is proxying correctly..."

          # Test HTTPS redirect from HTTP (HTTP redirects to HTTPS by design)
          REDIRECT_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:80/api/health)
          if [ "$REDIRECT_CODE" != "301" ]; then
            echo "Expected 301 redirect from HTTP, got $REDIRECT_CODE"
            exit 1
          fi
          echo "HTTP to HTTPS redirect working correctly"

          # Test health endpoint through nginx HTTPS (ignore self-signed cert)
          curl -f -k -v https://localhost:443/api/health || exit 1

          # Test static files over HTTPS
          curl -f -k -I https://localhost:443/_next/static/ || echo "Note: Static files may not exist in minimal test"
          
          # Test Let's Encrypt challenge path (certbot writes, nginx serves over HTTP)
          cd deployment
          DC_CMD="docker compose -f docker-compose.prod.yml -f docker-compose.test.yml --env-file .env.production"
          $DC_CMD exec -T certbot mkdir -p /var/www/certbot/.well-known/acme-challenge
          $DC_CMD exec -T certbot sh -c 'echo "test" > /var/www/certbot/.well-known/acme-challenge/test.txt'
          cd ..
          curl -f http://localhost:80/.well-known/acme-challenge/test.txt || exit 1
          
      - name: Test application endpoints (HTTPS)
        run: |
          echo "Testing application endpoints over HTTPS..."

          # Test API health over HTTPS
          echo "Testing /api/health..."
          HEALTH_RESPONSE=$(curl -k -s --max-time 10 https://localhost:443/api/health)
          echo "Health check response: $HEALTH_RESPONSE"

          # Test explore page loads over HTTPS
          echo "Testing /explore page..."
          if ! curl -f -k -s --max-time 10 https://localhost:443/explore | grep -q "<html"; then
            echo "ERROR: Explore page did not return HTML"
            curl -k -s --max-time 10 https://localhost:443/explore | head -20
            exit 1
          fi
          echo "Explore page OK"

          # Test security headers are present
          echo "Checking security headers..."
          curl -k -I --max-time 10 https://localhost:443/explore | grep -i "strict-transport-security" || echo "Warning: HSTS header missing"
          curl -k -I --max-time 10 https://localhost:443/explore | grep -i "x-frame-options" || echo "Warning: X-Frame-Options missing"
          curl -k -I --max-time 10 https://localhost:443/explore | grep -i "x-content-type-options" || echo "Warning: X-Content-Type-Options missing"
          
      - name: Test database connectivity
        run: |
          echo "Testing database operations..."
          cd deployment
          DC_CMD="docker compose -f docker-compose.prod.yml -f docker-compose.test.yml --env-file .env.production"

          # Check PostGIS is installed
          $DC_CMD exec -T postgres psql -U timetiles_user -d timetiles -c "SELECT PostGIS_Version();"

          # Check Payload schema exists
          $DC_CMD exec -T postgres psql -U timetiles_user -d timetiles -c "\dn payload"
          cd ..

      - name: Test container restart
        run: |
          ./deploy.sh restart

          # Wait for it to come back (check via nginx)
          sleep 10
          timeout 60 bash -c 'until curl -f --max-time 5 http://localhost:80/api/health 2>/dev/null; do sleep 2; done'

          echo "Container restart successful!"
          
      - name: Check resource usage
        run: |
          echo "=== Container Resource Usage ==="
          docker stats --no-stream
          
          echo "=== Docker Images ==="
          docker images | grep timetiles
          
      - name: Test backup and restore functionality
        run: |
          cd deployment
          DC_CMD="docker compose -f docker-compose.prod.yml -f docker-compose.test.yml --env-file .env.production"

          # Create some test data
          $DC_CMD exec -T postgres psql -U timetiles_user timetiles -c \
            "INSERT INTO payload.users (email, created_at, updated_at) VALUES ('test@backup.com', NOW(), NOW());"

          # Test database backup
          echo "Testing database backup..."
          ./deploy.sh backup db

          # Verify backup was created
          if ! ls backups/db-*.sql.gz > /dev/null 2>&1; then
            echo "Database backup failed - no backup file found"
            exit 1
          fi

          # Test full backup (with uploads)
          echo "Testing full backup..."
          ./deploy.sh backup full

          # Verify full backup files
          if ! ls backups/uploads-*.tar.gz > /dev/null 2>&1; then
            echo "Full backup failed - no uploads backup found"
            exit 1
          fi

          # List backups
          echo "Listing backups..."
          ./deploy.sh backup list

          # Get the latest backup file
          LATEST_BACKUP=$(ls -t backups/db-*.sql.gz | head -1)
          echo "Latest backup: $LATEST_BACKUP"

          # Delete test data
          $DC_CMD exec -T postgres psql -U timetiles_user timetiles -c \
            "DELETE FROM payload.users WHERE email = 'test@backup.com';"

          # Verify data is gone
          COUNT=$($DC_CMD exec -T postgres psql -U timetiles_user timetiles -t -c \
            "SELECT COUNT(*) FROM payload.users WHERE email = 'test@backup.com';" | tr -d ' ')
          if [ "$COUNT" != "0" ]; then
            echo "Failed to delete test data"
            exit 1
          fi

          # Test restore (auto-confirm for CI)
          echo "Testing restore..."
          echo "yes" | ./deploy.sh restore "$LATEST_BACKUP"

          # Verify data was restored
          COUNT=$($DC_CMD exec -T postgres psql -U timetiles_user timetiles -t -c \
            "SELECT COUNT(*) FROM payload.users WHERE email = 'test@backup.com';" | tr -d ' ')
          if [ "$COUNT" != "1" ]; then
            echo "Restore failed - test data not found after restore"
            exit 1
          fi

          echo "Backup and restore tests passed!"

          # Test backup cleanup
          echo "Testing backup cleanup..."
          ./deploy.sh backup clean

          # Clean up test data
          $DC_CMD exec -T postgres psql -U timetiles_user timetiles -c \
            "DELETE FROM payload.users WHERE email = 'test@backup.com';"

          cd ..

      - name: Collect logs on failure
        if: failure()
        run: |
          cd deployment
          docker compose -f docker-compose.prod.yml -f docker-compose.test.yml --env-file .env.production logs --tail=200

      - name: Cleanup
        if: always()
        run: |
          ./deploy.sh down || true
          docker system prune -f
