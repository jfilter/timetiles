name: Release Docker Images

on:
  push:
    tags:
      - 'v*'
  schedule:
    # Daily at 3:00 AM UTC (4:00 AM Berlin time)
    - cron: '0 3 * * *'
  workflow_dispatch:
    inputs:
      tag:
        description: 'Tag to build (e.g., v1.0.0, or leave empty for edge build)'
        required: false
        type: string

permissions:
  contents: read
  packages: write

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-main:
    name: Build Main Image (${{ matrix.platform }})
    runs-on: ${{ matrix.runner }}
    timeout-minutes: 30
    strategy:
      matrix:
        include:
          - runner: ubuntu-24.04
            platform: linux/amd64
          - runner: ubuntu-24.04-arm64
            platform: linux/arm64

    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          lfs: true

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push by digest
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: deployment/Dockerfile.prod
          platforms: ${{ matrix.platform }}
          outputs: type=image,name=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }},push-by-digest=true,name-canonical=true,push=true
          cache-from: type=gha,scope=main-${{ matrix.platform }}
          cache-to: type=gha,mode=max,scope=main-${{ matrix.platform }}

      - name: Export digest
        run: |
          mkdir -p /tmp/digests
          digest="${{ steps.build.outputs.digest }}"
          touch "/tmp/digests/${digest#sha256:}"

      - name: Upload digest
        uses: actions/upload-artifact@v6
        with:
          name: digests-main-${{ matrix.runner }}
          path: /tmp/digests/*
          if-no-files-found: error
          retention-days: 1

  build-allinone:
    name: Build All-in-One Image (${{ matrix.platform }})
    runs-on: ${{ matrix.runner }}
    timeout-minutes: 30
    strategy:
      matrix:
        include:
          - runner: ubuntu-24.04
            platform: linux/amd64
          - runner: ubuntu-24.04-arm64
            platform: linux/arm64

    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          lfs: true

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push by digest
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: deployment/Dockerfile.allinone
          platforms: ${{ matrix.platform }}
          outputs: type=image,name=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }},push-by-digest=true,name-canonical=true,push=true
          cache-from: type=gha,scope=allinone-${{ matrix.platform }}
          cache-to: type=gha,mode=max,scope=allinone-${{ matrix.platform }}

      - name: Export digest
        run: |
          mkdir -p /tmp/digests
          digest="${{ steps.build.outputs.digest }}"
          touch "/tmp/digests/${digest#sha256:}"

      - name: Upload digest
        uses: actions/upload-artifact@v6
        with:
          name: digests-allinone-${{ matrix.runner }}
          path: /tmp/digests/*
          if-no-files-found: error
          retention-days: 1

  test-deployment:
    name: Test Production Deployment
    runs-on: ubuntu-24.04
    needs: [build-main]
    timeout-minutes: 30

    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          lfs: true

      - name: Download amd64 digest
        uses: actions/download-artifact@v7
        with:
          name: digests-main-ubuntu-24.04
          path: /tmp/digests

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull image by digest and tag locally
        run: |
          DIGEST=$(ls /tmp/digests | head -1)
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@sha256:${DIGEST}
          docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@sha256:${DIGEST} timetiles-test:ci

      - name: Install bats
        run: sudo apt-get update && sudo apt-get install -y bats

      - name: Make scripts executable
        run: |
          chmod +x timetiles deployment/timetiles
          chmod +x deployment/tests/*.sh
          chmod +x deployment/tests/helpers/*.sh

      - name: Run deployment tests
        env:
          TIMETILES_IMAGE: timetiles-test
          TIMETILES_VERSION: ci
          SKIP_IMAGE_BUILD: 'true'
        run: |
          cd deployment/tests
          ./run-all.sh

      - name: Collect logs on failure
        if: failure()
        run: |
          cd deployment
          if [[ -f docker-compose.test.yml ]]; then
            docker compose -f docker-compose.prod.yml -f docker-compose.test.yml --env-file .env.production logs --tail=200 || true
          else
            docker compose -f docker-compose.prod.yml --env-file .env.production logs --tail=200 || true
          fi

      - name: Cleanup
        if: always()
        run: |
          ./timetiles down || true
          docker system prune -f || true

  merge-main:
    name: Create Main Multi-Arch Manifest
    runs-on: ubuntu-latest
    needs: [build-main, test-deployment]

    steps:
      - name: Download digests
        uses: actions/download-artifact@v7
        with:
          path: /tmp/digests
          pattern: digests-main-*
          merge-multiple: true

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            # For tagged releases: v1.0.0, 1.0, latest
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=raw,value=latest,enable=${{ github.event_name == 'push' && startsWith(github.ref, 'refs/tags/') }}
            # For scheduled/manual builds: edge
            type=raw,value=edge,enable=${{ github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && github.event.inputs.tag == '') }}

      - name: Create multi-arch manifest
        working-directory: /tmp/digests
        run: |
          COUNT=$(ls | wc -l)
          if [ "$COUNT" -ne 2 ]; then
            echo "ERROR: Expected 2 platform digests, got $COUNT"
            ls -la
            exit 1
          fi

          DIGESTS=$(printf '${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@sha256:%s ' *)

          # Build tag arguments from metadata
          TAG_ARGS=$(jq -cr '.tags | map("-t " + .) | join(" ")' <<< "$DOCKER_METADATA_OUTPUT_JSON")

          docker buildx imagetools create $TAG_ARGS $DIGESTS

      - name: Inspect manifest
        run: |
          TAG=$(jq -cr '.tags[0]' <<< "$DOCKER_METADATA_OUTPUT_JSON")
          docker buildx imagetools inspect "$TAG"

  merge-allinone:
    name: Create All-in-One Multi-Arch Manifest
    runs-on: ubuntu-latest
    needs: [build-allinone, test-deployment]

    steps:
      - name: Download digests
        uses: actions/download-artifact@v7
        with:
          path: /tmp/digests
          pattern: digests-allinone-*
          merge-multiple: true

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          flavor: |
            suffix=-allinone,onlatest=true
          tags: |
            # For tagged releases: v1.0.0-allinone, 1.0-allinone, latest-allinone
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=raw,value=latest,enable=${{ github.event_name == 'push' && startsWith(github.ref, 'refs/tags/') }}
            # For scheduled/manual builds: edge-allinone
            type=raw,value=edge,enable=${{ github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && github.event.inputs.tag == '') }}

      - name: Create multi-arch manifest
        working-directory: /tmp/digests
        run: |
          COUNT=$(ls | wc -l)
          if [ "$COUNT" -ne 2 ]; then
            echo "ERROR: Expected 2 platform digests, got $COUNT"
            ls -la
            exit 1
          fi

          DIGESTS=$(printf '${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@sha256:%s ' *)

          # Build tag arguments from metadata
          TAG_ARGS=$(jq -cr '.tags | map("-t " + .) | join(" ")' <<< "$DOCKER_METADATA_OUTPUT_JSON")

          docker buildx imagetools create $TAG_ARGS $DIGESTS

      - name: Inspect manifest
        run: |
          TAG=$(jq -cr '.tags[0]' <<< "$DOCKER_METADATA_OUTPUT_JSON")
          docker buildx imagetools inspect "$TAG"

  smoke-test:
    name: Smoke Test
    runs-on: ubuntu-latest
    needs: [merge-main, merge-allinone]
    timeout-minutes: 15

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Get image tag
        id: tag
        run: |
          if [ "${{ github.event_name }}" = "schedule" ]; then
            VERSION="edge"
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            TAG="${{ github.event.inputs.tag }}"
            if [ -z "$TAG" ]; then
              VERSION="edge"
            else
              VERSION="${TAG#v}"
            fi
          else
            TAG="${GITHUB_REF#refs/tags/}"
            VERSION="${TAG#v}"
          fi
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "Using version: $VERSION"

      - name: Pull main image
        run: |
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.tag.outputs.version }}

      - name: Start PostgreSQL container
        run: |
          docker network create timetiles-test

          docker run -d \
            --name postgres \
            --network timetiles-test \
            -e POSTGRES_USER=timetiles_user \
            -e POSTGRES_PASSWORD=test_password \
            -e POSTGRES_DB=timetiles \
            postgis/postgis:17-3.5-alpine

          # Wait for PostgreSQL to be ready
          echo "Waiting for PostgreSQL to be ready..."
          for i in {1..30}; do
            if docker exec postgres pg_isready -U timetiles_user -d timetiles; then
              echo "PostgreSQL is ready"
              break
            fi
            echo "Waiting... ($i/30)"
            sleep 2
          done

      - name: Start application container
        run: |
          docker run -d \
            --name timetiles \
            --network timetiles-test \
            -p 3000:3000 \
            -e DATABASE_URL=postgresql://timetiles_user:test_password@postgres:5432/timetiles \
            -e PAYLOAD_SECRET=test_secret_for_smoke_test_only \
            -e NEXT_PUBLIC_PAYLOAD_URL=http://localhost:3000 \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.tag.outputs.version }}

          # Wait for application to start
          echo "Waiting for application to start..."
          sleep 10

      - name: Check health endpoint
        run: |
          echo "Checking health endpoint..."
          max_attempts=30
          attempt=0

          while [ $attempt -lt $max_attempts ]; do
            if curl -f --max-time 5 http://localhost:3000/api/health 2>/dev/null; then
              echo ""
              echo "Health check passed!"
              exit 0
            fi
            echo "Waiting for application... (attempt $((attempt+1))/$max_attempts)"
            sleep 2
            attempt=$((attempt+1))
          done

          echo "Health check failed after $max_attempts attempts"
          echo "Application logs:"
          docker logs timetiles
          exit 1

      - name: Collect logs on failure
        if: failure()
        run: |
          echo "=== Application Logs ==="
          docker logs timetiles 2>&1 || true

          echo ""
          echo "=== PostgreSQL Logs ==="
          docker logs postgres 2>&1 || true

      - name: Cleanup
        if: always()
        run: |
          docker stop timetiles postgres 2>/dev/null || true
          docker rm timetiles postgres 2>/dev/null || true
          docker network rm timetiles-test 2>/dev/null || true
